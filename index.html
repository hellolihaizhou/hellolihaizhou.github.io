<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="李海洲的成长之路" type="application/atom+xml" />






<meta name="description" content="Nothing for nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="李海洲的成长之路">
<meta property="og:url" content="http://lihaizhou.top/index.html">
<meta property="og:site_name" content="李海洲的成长之路">
<meta property="og:description" content="Nothing for nothing">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李海洲的成长之路">
<meta name="twitter:description" content="Nothing for nothing">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lihaizhou.top/"/>





  <title>李海洲的成长之路</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	
	<a href="https://github.com/hellolihaizhou" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李海洲的成长之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2019/03/11/Android-系统层捕捉所有应用崩溃情况推送到钉钉实践之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/11/Android-系统层捕捉所有应用崩溃情况推送到钉钉实践之路/" itemprop="url">Android 系统层捕捉所有应用崩溃情况推送到钉钉实践之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-11T22:19:11+08:00">
                2019-03-11
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/11/Android-系统层捕捉所有应用崩溃情况推送到钉钉实践之路/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/11/Android-系统层捕捉所有应用崩溃情况推送到钉钉实践之路/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  526
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>项目痛点</strong><br>出现偶现崩溃或<code>ANR</code>，因为没有开启日志开关，后面尝试复现又比较困难，研发同事比较苦恼，无从下手<br>还有一个测试同事抓取日志后还要记录时间点，再上传到JIRA上，研发同事下载日志还需要搜索报错点，整个流程比较费时</p>
<p><strong>初步想法</strong><br>可不可以将所有<code>ANR</code>,<code>Crash</code>等出错信息的关键日志片段直接传给服务器，在后面的摸索过程中发现钉钉可以提供对外的URL接口，这样的话直接传给钉钉就很方便了，正好平时的办公用的也是这个软件，这样一来就省去了很多的步骤，一步到位</p>
<p>以下是实做的步骤记录，只是实现了一个初稿，后面还需要不断优化完善</p>
<p><strong>Step1： 获取钉钉的<code>Webhook</code>地址</strong><br>这个地址后面作为推送的目标地址</p>
<p>在钉钉中添加机器人接口的步骤参见官网文档<br><a href="https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.XJQ2yZ&amp;treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="noopener">https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.XJQ2yZ&amp;treeId=257&amp;articleId=105735&amp;docType=1</a></p>
<p>通过以上步骤拿到了Laucnher的Webhook地址，如下:<br><a href="https://oapi.dingtalk.com/robot/send?access_token=a937a86122149aa52a694dd79fae2cdec1c7e448c62bff31471088ec13e941" target="_blank" rel="noopener">https://oapi.dingtalk.com/robot/send?access_token=a937a86122149aa52a694dd79fae2cdec1c7e448c62bff31471088ec13e941</a></p>
<p><strong>Step2：源码层增加上报机制</strong><br>之所以考虑在源码层中修改，是因为我们需要监测系统中所有应用的出错情况，想到<code>AMS</code>中的<code>Crash</code>弹框，猜想其中一定有相关的写入报错日志的操作</p>
<p><img src="https://github.com/hellolihaizhou/FrescoDemo/blob/master/handleApplicationCrash.png?raw=true" align="left" style=" width:700px;height:300 px"><br><br><br><br><br><br><br><br></p>
<p>这里调用了<code>handleApplicationCrashInner</code>这个函数，接着看这个函数<br><img src="https://github.com/hellolihaizhou/FrescoDemo/blob/master/handleApplicationCrashInner.png?raw=true" align="left" style=" width:700px;height:300 px"><br><br><br><br><br><br><br><br><br><br></p>
<p>这里追加了一行日志，在应用层添加会造成<code>crash</code>的代码片段，看看这行日志打出的信息</p>
<p><img src="https://github.com/hellolihaizhou/FrescoDemo/blob/master/crashLog.png?raw=true" align="left" style=" width:700px;height:300 px"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>这里会打出<code>eventtype</code>类型，报错进程，以及关键的堆栈信息，其中的<code>eventtype</code>包括了<code>watchdog</code>、<code>anr</code>、<code>wtf</code>、<code>lowmem</code>、<code>native_crash</code>、<code>crash</code><br>完全满足我们的要求，接下来就是如何把这段发给钉钉了<br>在<code>handleApplicationCrashInner</code>中增加接口<code>reportAllErrorToXunDingTalk</code></p>
<p><img src="https://github.com/hellolihaizhou/FrescoDemo/blob/master/AddReportFunction.png?raw=true" align="left" style=" width:700px;height:300 px"><br><br><br><br><br><br><br></p>
<p><code>reportAllErrorToXunDingTalk</code>接口如下：<br><img src="https://github.com/hellolihaizhou/FrescoDemo/blob/master/report1.png?raw=true" align="left" style=" width:700px;height:300 px"><br><img src="https://github.com/hellolihaizhou/FrescoDemo/blob/master/report2.png?raw=true" align="left" style=" width:700px;height:300 px"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<p>这个时候应用端报错的话话，钉钉群会收到消息<br><img src="https://github.com/hellolihaizhou/FrescoDemo/blob/master/dingding.png?raw=true" align="left" style=" width:700px;height:300 px"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<hr>
<font color="#000000" size="2" face="楷体">good night!</font>


          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/11/18/小米一面二面记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/小米一面二面记录/" itemprop="url">小米一面二面记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T22:43:26+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/18/小米一面二面记录/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/11/18/小米一面二面记录/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,708
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><strong>一面</strong></strong><br>这次电话面试，没有准备，面的不太好，面试官很nice，很有耐心，差不多电话面试了一个小时<br>依据回忆大致列了出来一面的题目如下:</p>
<p><strong>View的绘制流程</strong><br>回答:measure，layout，draw<br><code>回答参考样式</code>:<br>View的整个绘制流程可以分为以下三个阶段：</p>
<p>measure: 判断是否需要重新计算View的大小，需要的话则计算；<br>layout: 判断是否需要重新计算View的位置，需要的话则计算；<br>draw: 判断是否需要重新绘制View，需要的话则重绘制<br>涉及的东西比较多，完整清晰的描述下来比较困难，这里不写了</p>
<p><strong>JNI有用过吗？讲一讲</strong><br>回答: debug问题用过，项目中也有用过，自己开发的没有过<br>面试官: emmmmm…….</p>
<p><strong>谈谈设计模式</strong><br>回答: 说了单例，build，观察者，责任链<br><code>回答参考样式</code>:<br>单例模式<br>private Singleton(){}<br>private static class SingletonHolder{<br>    public static Singleton instance = new Singleton();<br>}<br>public static Singleton newInstance(){<br>    return SingletonHolder.instance;<br>}<br>在装载该内部类时才会去创建单例对象，起到了一个延迟加载的目的，另外因为是静态的，所以还是线程安全</p>
<p>builder模式<br>Android源码中，我们最常用到的Builder模式就是AlertDialog.Builder，大致如下<br>AlertDialog.Builder builder = new AlertDialog.Builder(context);<br>        builder.setIcon(R.drawable.icon);<br>        builder.setTitle(“Title”);<br>        builder.setMessage(“Message”);<br>        builder.create().show();<br>我个人的理解是不采用这种模式，需要写多个构造函数，调用的地方根据需要传进不同数目的参数，参数含义看不出，可读性差</p>
<p>采用这种模式后，可读性增强，减少了很多重复的代码，结构清晰，配置的意义一目了然</p>
<p>观察者模式<br>观察者模式就是：当一个对象的状态发送改变时，所有依赖于它的对象都能得到通知并被自动更新<br>我个人的理解就是接口回调，自己的开发的Launcher中也用到了这种模式，广播接收到电量变化后通知所有的监测者，所有的监测着存在一个数组中，监测者通过注册接口add自身进来，并实现这个接口重写接口的方法，还有Android的广播机制，其本质也是观察者模式，监测者接收变化是一个被动接收的过程<br>其他还有不少种，不一一列举了，面试的时候一般说个两三种也差不多了，说太多面试官也会累的吧，哈哈哈</p>
<p><strong>内存泄露和内存优化如何处理的，谈一谈</strong><br>回答: blabla<br>这个比较简单<br><code>回答参考样式</code>:<br>内存泄露</p>
<p>对于Java来说，就是new出来的Object放在Heap上无法被GC回收（内存中存在无法被回收的对象）；内存泄漏发生时的主要表现为内存抖动，可用内存慢慢变少</p>
<p>Step1: 用AndroidStudio的Memory Monitor大致判断下是否有问题<br>AndroidStudio自带的Memory Monitor可以方便的观察堆内存的分配情况，并且可以粗略的观察有没有Memory Leak,其实就是看看是否有内存抖动，还有是否存在一些该降下来的时候没有降下来</p>
<p>官网上介绍的很详细关于这个工具的使用(<a href="https://developer.android.google.cn/studio/profile/memory-profiler" target="_blank" rel="noopener">https://developer.android.google.cn/studio/profile/memory-profiler</a>)<br>点击Memory Monitor的Dump Java Heap，会生成一个.hprof文件，AndroidStudio会自动使用HeapViewer打开，会有一个可视化界面出来，这里限于篇幅，不贴截图了<br>主要关注Total Count这个信息点，看看Activity的实例数目是否正常，内存泄露一般都是指的Activity泄露了<br>这个工具的话只能大概看出是否有问题，具体的问题点需要借助于MAT来分析</p>
<p>Step2: MAT分析问题的具体点<br>使用MAT打开这个hprof文件后，重点关注Histogram这项，这项可以列出内存中每个对象的名字、数量以及大小使用Histogram大致步骤</p>
<p>点击Histogram并在顶部的Regex中输入比如MainActivity进行正则匹配，会将包含“MainActivity”的所有对象全部列出了出来，其中第一行就是MainActivity的实例。<br>对着想查看的对象点击右键 -&gt; List objects -&gt; with incoming references 查看具体MainActivity实例。<br>对想要查看的对象实例点击右键-&gt; Path To Gc Roots -&gt; exclude weak reference（排除掉软引用）。<br>PS：如果图标的左下角有个圆圈，这代表这个引用可以被Gc Roots引用到，所以不能被回收，从而它所持有的其它引用也无法被回收了，还有其包含的资源<br>         不过有圆圈并不代表一定是导致内存泄漏的原因，有些对象就是需要在内存中存活的，需要区别对待</p>
<p>其他工具：LeakCanary</p>
<p>LeakCanary是square出品的一个检测内存泄漏的库，集成到App之后便无需关心，在发生内存泄漏之后会Toast、通知栏弹出等方式提示，可以指出泄漏的引用路径，而且可以抓取当前的堆栈信息供详细分析</p>
<p>这个工具用起来很简单，泄漏后会看到通知栏提示打开看下就知道泄漏点在哪里</p>
<p><strong>如何做到进程互斥，比如File文件的读取</strong><br>回答:项目中有用到过file文件读取写值，只有一个用，所以没有考虑多进程同步写的情况<br>面试官: emmmmmmmm……..ok……….<br>个人理解，应该做不到，就像SharePreference这种文件共享，也做不到多进程同步安全</p>
<p><strong>项目中有用到什么跨进程吗？</strong><br>回答: blabla<br>这个比较简单，一般做为起个开头的作用，后面面试官一般会细问<br><code>回答参考样式</code>:<br>这个问题<br>Content Provider<br>Content Provider提供了一种在多个应用程序之间数据共享的方式（跨进程共享数据）<br>广播（Broadcast）<br>广播是一种被动跨进程通讯的方式，在应用程序中发送广播比较简单。只需要调用sendBroadcast方法即可。该方法需要一个Intent对象。通过Intent对象可以发送需要广播的数据。<br>Service</p>
<p>利用AIDL Service实现跨进程通信<br>优势是不会像广播那样在手机中的广播较多时会有明显的时延，甚至有广播发送不成功的情况出现</p>
<p><strong>binder的framework机制</strong><br>回答: blabla一堆<br><code>回答参考样式</code><br>Binder服务的类别<br>实名服务：<br>Android的实名Binder服务都是系统提供的，如AMS，PMS，WMS等，实名服务可以通过ServiceManager查询到<br>匿名服务：<br>普通应用开发的Binder服务，鉴于这种服务不能通过ServiceManager查询到，使用者又是如何得到该服务的引用对象呢？<br>Android通过framework提供了一种启动java匿名Binder服务的方法，首先某个应用通过bindService()方法发出一个Intent，Framework根据Intent找到对应的组件Service并启动它，包在组件Service中的Binder服务也将同时创建出来。随后framework会把服务的Ibinder对象通过ConnectivityManager的回调方法onServiceConnected()传回到应用，这样应用就得到匿名Binder服务的引用对象，也就能使用组件Service中的匿名Binder服务了，在这里Android的framework使用intent代替了Binder服务的名称来查找对应的服务，同时也承担了ServiceManager的工作，解析intent并传回服务的引用对象<br>应用层实际需要使用的是代理对象，所以在使用前需要将引用对象转换为代理对象，转换方式举例如下：<br>ICameraService service = ICameraService.Stub.asInterface(binder);<br>这里的这个asInterface作用是通过引用对象这个参数来新创建一个Binder代理对象，代理对象中包含了引用对象<br>一般的对象作为参数传递没有太大的问题，只需要实现序列化和反序列化就能实现。但是，当Binder对象作为参数传递时，就会面临实体对象和引用对象相互转换的问题，为了能够让上层使用方便，这个转换过程在驱动中自动完成<br>回答参考样式:<br>对Binder调用的过程如下：<br>1.客户端从某个线程中发起调用，将参数打包后通过ioctl()函数传递给驱动<br>2.客户端挂起并等待ioctl()返回函数的结果<br>3.驱动记录下调用进程的信息，然后根据调用的Binder对象信息寻找服务所在的进程<br>4.驱动找到服务进程后先查看进程中是否有空闲进程，没有则通知服务进程创建<br>5.得到空闲进程后根据驱动中保存的BBinder对象的指针调用相应的函数<br>6.函数返回后再通过ioctl()把结果打包传递给驱动<br>7.驱动根据返回信息查找调用者线程<br>8.找到调用者线程后唤醒它，并通过ioctl()函数把结果传递回去<br>9.客户端的线程得到返回结果后继续运行</p>
<p><strong>Handler的机制</strong><br>回答: 回答的差不多<br><code>回答参考样式</code>:<br>1、handler封装消息的发送（主要包括消息发送给谁）<br>2、Looper——消息封装的载体<br>（1）内部包含一个MessageQueue，所有的Handler发送的消息都走向这个消息队列；<br>（2）Looper.Looper方法，一个死循环，不断地从MessageQueue取消息，如果有消息就处理消息，没有消息就阻塞。<br>延伸为什么looper死循环不会卡死<br>主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞，阻塞最终是通过epoll机制实现。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。<br>3、MessageQueue，一个消息队列，添加消息，处理消息<br>4、handler内部与Looper关联，handler-&gt;Looper-&gt;MessageQueue, handler发送消息就是向MessageQueue队列发送消息。<br>总结：handler负责发送消息，Looper负责接收handler发送的消息，并把消息回传给handler自己, MessageQueue存储消息的容器。</p>
<p><strong>window,activity, viewrootimpl之间的关系，window在activity viewrootimpl之间扮演了什么角色，一个activity对应几个viewrootImpl，dialog有没有viewrootImpl</strong><br>回答: 不知道，【这个知识点比较重要的，研究过时间久了就忘了<br><code>回答参考样式</code>:<br>ViewRootImpl是实际管理Window中所有View的类,每个Activity中ViewRootImpl数量取决于调用mWindowManager.addView的调用次数<br>window是一个抽象的概念，每一个window都对应一个view和ViewRootImpl，window通过ViewRootImpl和View建立联系，因此window并不是实际存在，是以View形式存在的<br>1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。<br>2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。<br>3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等<br>4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等</p>
<p><strong>线程同步的方式，synchronized的原理，作用普通对象和静态方法的区别</strong><br>回答: synchronized或者lock，一个是类锁一个是对象锁，作用域不同，静态方法持有的是类锁，普通方法是对象锁<br><code>回答参考样式</code>:<br>synchronized，Lock<br>先谈谈synchronized<br>普通方法加synchronized是对类的当前实例进行加锁，类的两个不同实例就没有这种约束了，相当于this.synchronized。<br>static方法加 synchronized控制类的所有实例的访问<br>再谈谈Lock<br>Lock能完成Synchronized所实现的所有功能，Synchronized会自动释放锁，但是Lock要手工释放，并且必须在finally从句中释放<br>Lock和synchronized有以下几点不同：</p>
<p>1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；<br>2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；<br>3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；<br>4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>5）Lock可以提高多个线程进行读操作的效率。<br>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择</p>
<p><strong>java的内存模型讲一讲</strong><br>回答: 静态方法区，堆，栈，以及各自存放的数据类型，回头想了想这不是内存结构吗<br><code>回答参考样式</code>:<br>先说下内存结构<br>栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。<br>堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域<br>方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。方法区是被Java线程锁共享的，方法区也是堆中的一部分，就是我们通常所说的Java堆中的永久区 Permanet Generation<br>再开始谈内存模型<br>涉及内容较多，面试时谈谈主内存和工作内存<br>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝<br>主内存<br>主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。<br>工作内存<br>主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的</p>
<p><strong>加载类的流程，比如普通方法，静态方法，构造函数的加载顺序</strong><br>回答:先静态再构造再普通<br><code>回答参考样式</code>:<br>加载时<br>静态代码块&gt;静态属性&gt;静态方法&gt;普通属性&gt;普通代码块&gt;构造方法&gt;普通方法<br>执行时<br>静态代码块&gt;静态属性&gt;普通代码块&gt;构造方法, 静态方法和普通方法会在调用的时候才会执行</p>
<p><strong>单例模式怎么用，静态内部类的方式，如果带参数context呢？</strong><br>回答: 静态内部类，优点答上，如果带参数没答上，当时回答了带个Application的Context不就好了，哈哈哈哈，傻爆了，容易产生生命周期不一致，内存泄露等问题<br>静态内部类写法如下，这个一般都烂熟于心了<br>public class SingleTon{<br>  private SingleTon(){}<br>  private static class SingleTonHoler{<br>     private static SingleTon INSTANCE = new SingleTon();<br> }<br>  public static SingleTon getInstance(){<br>    return SingleTonHoler.INSTANCE;<br>  }<br>}</p>
<p><code>回答参考样式</code>:<br>静态内部类的优点：<br>外部类加载时不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。即当SingleTon第一次被加载时，并不需要去加载SingleTonHoler，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE,第一次调用getInstance()方法会导致虚拟机加载SingleTonHoler类，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。<br>静态内部类的缺点:<br>传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数，所以，我们创建单例时，可以在静态内部类与DCL模式里自己斟酌。</p>
<p><strong>知道threadlocal吗？</strong><br>答: 不知道，当时听着非常耳熟<br>后来想了下，Hanlder机制中的looper不就是用的这玩意嘛，先看下threadLocal的官方解释，然后再看下Looper源码<br>Threadlocal官方解释如下:<br>Implements a thread-local storage, that is, a variable for which each thread<br>has its own value. All threads share the same {@code ThreadLocal} object,<br>but each sees a different value when accessing it, and changes made by one<br>thread do not affect the other threads. The implementation supports<br>{@code null} values</p>
<p>意思是实现了一个线程本地存储，每个线程都有自己独立的变量。所有的线程都共享者这一个ThreadLocal对象，<br>但是各自访问的是不同的值，并且当一个线程的值发生改变之后，不会影响其他的线程的值。<br>说白了就是每个线程都有个变量的拷贝，各自修改互不影响<br>看了下looper源码，的确如此<br>ThreadLocal是个泛型，T指代的是在线程中存取值的类型，这个例子里的T对应的就是Looper<br><code>回答参考样式</code>:<br>Android Handler机制中的Looper对象存储便是通过threadLocal存储，所以可以认为Looper对象是和线程绑定的。子线程中创建一个Looper时，一般是通过调用Looper.prepare方法来在线程中新建一个Looper的对象，其原理采用的便是ThreadLocal作为存储结构，创建的这个looper对象只会存储在当前线程中，这里的存储是通过ThreadLocal的set方法，将值set进各自线程的map中，key为当前的ThreadLocal对象。我们这个例子里，ThreadLocal是静态的，也就是多线程访问的都是同一份</p>
<p><strong>startservice和bindservice有什么区别</strong><br>当时回答: 和Activity的生命周期一个是同步，一个不同步，回答草率了<br><code>回答参考样式</code>:<br>1.startservice开启的服务.一旦服务开启, 这个服务和开启他的调用者之间就没有任何的关系了.<br>调用者不可以访问 service里面的方法. 调用者如果被系统回收了或者调用了ondestroy方法, service还会继续存在<br>2.bindService开启的服务,服务开启之后,调用者和服务之间还存在着联系 , 一旦调用者挂掉了.service也会跟着挂掉，退出activity时必须调用unbindService方法，否则会报ServiceConnection泄漏的错误<br>startService()和bindService()两种模式是完全独立的，可以绑定一个已经通过startService()方法启动的服务。例如：一 个后台播放音乐服务可以通过startService(intend)对象来播放音乐。可能用户在播放过程中要执行一些操作比如获取歌曲的一些信息，此时 activity可以通过调用bindServices()方法与Service建立连接。这种情况下，stopServices()方法实际上不会停止服务，直到最后一次绑定关闭。</p>
<p>数据结构部分</p>
<ol>
<li>如何判断一个链表是否是一个环<br>回答: 不知道<br>面试官: emmmmmm…..</li>
<li>二分查找<br>回答：巴拉巴拉说的差不多</li>
</ol>
<p>隔了几天，礼拜五下午两点小米二面</p>
<p>谈谈进程和线程的区别，说下概念<br>启动Service的方式<br>线程同步的方式，synchronized和lock的区别，死锁的条件<br>读取文件如何做到进程互斥<br>ANR问题怎么分析<br>电量优化怎么做的<br>Activity的启动模式，举个例子比如A启动B，生命周期是怎么样的<br>跨进程的方式有哪些，contentprovider和广播如何选择，基于什么考虑</p>
<p>算法题<br>一个数组如何区分正负数<br>一个台阶，一次走一格或者走两格，有多少种走法</p>
<p>当时从公司出来加上一路跑下楼梯，到了外边，正好在下小雨，风又很大，好几次面试官说的啥都没听清，期间还冷场了，不知道面试官刚刚是否问了问题，面试官也没吱声，总的比较简单，感觉像是在网上找的面试题，but还是挂了！临了面试官说了到时候有需要会通知，凉了</p>
<p>总结下来<br>算法是最大的硬伤，二面问的算法问题，很眼熟啊，可以肯定的是网上稍微搜搜Android常见面试算法题肯定能搜到，看来还是要准备下<br>感谢一面的哥们，让我通过了，二面的仁兄没让我过，也实属正常，毕竟确实菜鸟</p>
<p>因时间问题，整篇文章后续会持续改善答案包括排版样式</p>

          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/08/28/月度小结-20180828/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/28/月度小结-20180828/" itemprop="url">月度小结--20180828</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-28T10:18:16+08:00">
                2018-08-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/28/月度小结-20180828/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/08/28/月度小结-20180828/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  813
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好长一段时间没有更新了，这段时间一些事搞得心神不宁，智商也常常掉线，当然了这不是没有更新的借口，好吧，还是懒啊，是可恶的惰性！  </p>
<p>这一个多月,一直在维护老项目，总的来说比较清闲</p>
<p>这段时间的近况大致如下:</p>
<ul>
<li><strong><code>姐姐的定亲</code></strong><br>姐姐定亲日子安排在了国庆节，到时候去趟镇江，一想到老姐终于快要嫁出去了，实属不易啊，但愿一切顺利，拜托拜托！<br>前阵子老妈电话里特意嘱咐我，到时候要穿的体面点，发型弄一弄，人看着要精神点。一顿昂昂昂的答应后，翻了翻衣柜，只有零星的几件衣服，春夏秋冬都在眼前，尽收眼底。其中还夹杂着几件公司的文化衫，翻来翻去找不到一件合适的衣服，已经记不得上次买衣服是什么时候了，这大概就是一个单身屌丝的苦逼生活把，哈哈哈，生活不易</li>
</ul>
<ul>
<li><strong><code>日益发酵的焦虑感</code></strong><br>前段时间一个华为的兄弟出来创业了，问我有没有兴趣一起。考虑再三，想到房贷背着，便婉言谢绝了。<br>不过这事儿倒又提醒了我，像是在我耳边打了个一个响指，反思下现在的处境，日复一日的搬砖，每天公司住所两点一线，搭着拥挤的地铁，究竟是为了什么？我的人生目标是什么？这样的日子看上去没问题，一切顺利的话，每月还能攒下一些。<br>其实不然，隐藏着很大的危机在里面，就是抗风险能力太弱，就像一块有了裂纹的玻璃，禁不住一点点的敲打。一旦停止工作，便没有了收入来源，接踵而至的账单可能便难以付清。<br>如何能够提升自己的抗风险能力呢？答案肯定是<code>钱</code>，接下来的一段时间，将好好思考副业的问题，幸好现在的公司很轻松有大把的时间，不能再白白浪费掉时间了，下个月在更新这个进展，目标是起码先有方向。</li>
</ul>
<ul>
<li><strong><code>读书的重要性</code></strong><br>不一定是技术方面的，接下来的时间读书的重心在经济类理财类。<br>现在逐渐开始意识到读书的重要性，与一些前辈交谈时，时常会钦佩对方的知识面是如此广泛，回头想想，也许是自己的知识面太狭窄了，后悔以前没有多看书，现在大脑经常短路，语言表达能力堪忧，就像我现在正在打的这些字，我在说的啥，我想表达啥，读着都费劲，这就是！不读书的结果！哈哈哈，苦笑~</li>
</ul>
<p>如上便是这段时间的一些事以及感悟，啰里啰嗦，也许以后回过头再看会觉得可笑，不过确实我现在真实的处境和想法</p>
<p><strong>时间飞逝，且行且珍惜</strong></p>
<hr>
<font color="#000000" size="2" face="楷体">草稿写于住所，公司电脑前，听着一首土味情歌</font>
          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/07/03/对优化代码的一点思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/03/对优化代码的一点思考/" itemprop="url">对优化代码的一点思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-03T23:50:55+08:00">
                2018-07-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/03/对优化代码的一点思考/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/03/对优化代码的一点思考/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,559
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看了项目上的代码后，发现随着项目功能的不断扩充，代码量已经比较庞大，很多业务代码看着一头雾水，可谓又臭又长，还有很多类似的代码多次重复出现，对静态static关键字的滥用，出了问题debug起来异常痛苦。这几天一直在思考，如果要优化代码的话，应该从哪些地方着手呢？<br>如下是个人总结，比较简单基础，不涉及设计模式，后面会找时间写设计模式相关的内容</p>
<p><strong>1.避免又臭又长的函数</strong><br>这点看项目中的代码时，经常能看到一些动辄就是上百行的函数，一大堆业务逻辑代码封在一个函数，看的十分头疼，如果写这个函数的同事离职了，后续接手的同事的话，那么对接手的同事会是一件很痛苦的事，这种巨无霸函数阅读起来很困难，往往读着读着就迷失了，让人丧失往下看的兴趣。另外一点就是，这种很长的函数，往往可能会存在一些重复的代码，这些重复的代码剥离出来的话，可以供其他函数调用，这样也可以降低整个工程的代码量。<br>函数尽可能的简洁短小，一个函数只做与函数名相关的事，很长的函数需要考虑按照功能独立出来为一个个单独的函数，并为这些独立出来的函数取一个与功能符合的名字，这样代码的阅读性大大提高。这里需要把握好一个度，不是说函数越短越好，比如说只有一两句的代码也封装成一个函数，这就有点物极必反了。<br>另外，如果这个函数比较复杂，参数比较多，也可以考虑独立出来一个类，将参数作为类的属性</p>
<p><strong>2.避免非常复杂的赋值表达式或if判断条件</strong><br>项目代码中经常会看到一些非常长的赋值表达式或者if判断中的判断条件，可能起初并不长，后面业务需要，增加一些限制判断条件，渐渐的就变成了一个非常长的表达式，有时候在界面中看不下还有鼠标往右拖动才能看到后面的，这样的代码看着十分蛋疼，容易迷失<br>这种很长的表达式就可以考虑分解出来，引入解释型变量，这样可阅读性大大增强。如果这个表达式其他地方也会用到，这个时候就可以考虑独立出来为一个函数，也方便复用。如果表达式中有不同功能的代码，可以按照功能分解出不止一个函数</p>
<p><strong>3.避免对函数参数进行赋值</strong><br>项目代码中发现有些函数的传参进来后根据一些业务判断被直接赋了其他值，这个也是十分不建议的，这种做法改变了原始输入值，因为这个函数后面可能还会需要用到原始值，这里最好的做法是引入临时变量，将传参赋值给这个临时变量，这样就不会改变原始值</p>
<p><strong>4.避免一个函数过多的参数</strong><br>项目代码中经常会出现一个函数有多达五六个参数，看起来比较头疼，比较舒服的函数是一两个参数，最舒服的情况是没有参数，这样的代码最易复用，看起来阅读性也比较强</p>
<p><strong>5.避免一个类中出现和该类不相干的函数</strong><br>也就是尽可能遵循单一职责原则，与该类不相干的函数应考虑移走，放在更合适的地方<br>一个项目变得庞大的时候，很多时候需要增加接口，为了图省事直接就在需要修改的地方后面增加一个函数，久而久之，这个类中多出很多和该类不相干的函数，容易看的一头雾水</p>
<p><strong>6.避免不同类中同样功能的函数</strong><br>不同类中出现同样功能的函数，这个是否观察不同类是不是同级别的，是否可以搞一个父类出来定义这些基础的行为，这样不同子类就不用再写多个重复功能的函数了，如果这些不同类看起来扯不上联系，可以将这些同样功能的函数剥离出来放到比如工具类中<br>宗旨只有一个: 尽可能重复性的写相同的代码</p>
<p><strong>7.一堆组合起来关联性强的数据可以考虑做成实体类</strong><br>定义成实体类后，数据更好管理，代码结构更加清晰，也便于后面功能迭代，常用做法给这个实体类定义set, get方法</p>
<p><strong>8.避免业务逻辑和UI界面类混合在一起</strong><br>这在项目代码中很常见，随便打开一个Activity类，其中都有大量的业务逻辑代码，随着项目功能的不断迭代，业务逻辑变得十分庞大，整个界面类显得十分臃肿，难以阅读，我们在工作过程中往往追求功能ok就好，没有考虑将代码按照功能职责分层剥离<br>这个时候就可以考虑引入MVP架构设计，这一点因叙述起来篇幅会比较大，后面会单独写一篇文章讨论</p>
<p><strong>9.抽取子类共同行为放到父类中</strong><br>子类中有共同的行为的话，可以抽取出来放到父类中作为一个模板函数，可以精简不少代码量，这个模板函数意味着不会随着功能迭代或者子类增加而变动，对一些特殊的函数只有个别子类才会用到的就放在子类里</p>
<hr>
<font color="#000000" size="2" face="楷体">住所，汗衫</font>
          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/07/03/Android输入系统系列-4-分发输入消息/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/03/Android输入系统系列-4-分发输入消息/" itemprop="url">Android输入系统系列(4)----分发输入消息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-03T23:14:08+08:00">
                2018-07-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/03/Android输入系统系列-4-分发输入消息/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/03/Android输入系统系列-4-分发输入消息/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  505
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面讲过C++中起来的线程循环函数是threadLoop，下面看看InputDispatcherThread这一分发消息的线程的循环体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是简单的调用了InputDispatcher的dispatchOnce()<br>接着看这个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line">    nsecs_t nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        <span class="function">AutoMutex <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run a dispatch loop if there are no pending commands.</span></span><br><span class="line">        <span class="comment">// The dispatch loop might enqueue commands to run afterwards.</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里核心的代码只有一行dispatchOnceInnerLocked，查看haveCommandsLocked()代码得知当mCommandQueue不为空时，<br>便会调用dispatchOnceInnerLocked函数来进行分发消息</p>
<p>下面接着看dispatchOnceInnerLocked这个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//省略部分代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            <span class="comment">//队列不为空的话，从队列中取消息</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//省略部分代码   </span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">     <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="comment">//消息类型是按键消息</span></span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAppSwitchKeyEventLocked(typedEntry)) &#123;</span><br><span class="line">                resetPendingAppSwitchLocked(<span class="keyword">true</span>);</span><br><span class="line">                isAppSwitchDue = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">                dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEventLocked(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要工作先是从mInboundQueue中取消息，这个mInboundQueue是不是很眼熟，就是上篇文章中讲述的读取消息最后存放到mInboundQueue中，读取到消息后呢，根据消息的类型进行处理，这里还是以Key消息为例，调用到了dispatchKeyLocked这一函数，这里就正式开始了消息分发之旅了</p>
<p>后面便是层层调用分发，历程还是比较复杂的，这里就不细细分解，绘制了一张流程图如下</p>
<p><img src="https://github.com/hellolihaizhou/hellolihaizhou.github.io/blob/master/2018/07/03/Android%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%B3%BB%E5%88%97-4-%E5%88%86%E5%8F%91%E8%BE%93%E5%85%A5%E6%B6%88%E6%81%AF/%E6%B5%81%E7%A8%8B%E5%9B%BE.png?raw=true" align="left" style=" width:300px;height:150 px"><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<hr>
<font color="#000000" size="2" face="楷体">住所，晚上，汗衫，电脑前，看着世界杯瑞士对阵瑞典队</font>





          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/07/03/Android输入系统系列-3-读取RawEvent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/03/Android输入系统系列-3-读取RawEvent/" itemprop="url">Android输入系统系列(3)----读取RawEvent</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-03T22:10:50+08:00">
                2018-07-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/03/Android输入系统系列-3-读取RawEvent/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/03/Android输入系统系列-3-读取RawEvent/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,744
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前系列文章(1)中提到InputManager中的start方法里调用了ReaderThread-&gt;run，可是我们在InputReader中没有看到run方法<br>这一点和java中的线程运行方式有点区别，C下的线程运行是threadLoop这个方法，这是个虚函数，追溯到父类线程中是有run这个方法<br>层层往下跟就会跟到threadLoop方法，如果threadLoop返回false则会退出循环</p>
<p>下面看下InputReader的threadLoop方法，可见这里返回true，说明是反复循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frameworks\<span class="keyword">native</span>\services\inputflinger\InputReader.cpp</span><br><span class="line">bool InputReaderThread::threadLoop() &#123;</span><br><span class="line">    mReader-&gt;loopOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面着重看下这里的loopOnce函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">frameworks\<span class="keyword">native</span>\services\inputflinger\InputReader.cpp</span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="comment">//上文中讲过此处的getEvents，作用是获取Event，读取到的Event保存在mEventBuffer中，并返回Event的数量</span></span><br><span class="line">    size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        <span class="function">AutoMutex <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mReaderIsAliveCondition.broadcast();</span><br><span class="line">        <span class="comment">//判断读取到的event数量，大于0则进入processEventsLocked处理</span></span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            processEventsLocked(mEventBuffer, count);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//省略部分代码</span></span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send out a message that the describes the changed input devices.</span></span><br><span class="line">    <span class="keyword">if</span> (inputDevicesChanged) &#123;</span><br><span class="line">        mPolicy-&gt;notifyInputDevicesChanged(inputDevices);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flush queued events out to the listener.</span></span><br><span class="line">    <span class="comment">// This must happen outside of the lock because the listener could potentially call</span></span><br><span class="line">    <span class="comment">// back into the InputReader's methods, such as getScanCodeState, or become blocked</span></span><br><span class="line">    <span class="comment">// on another thread similarly waiting to acquire the InputReader lock thereby</span></span><br><span class="line">    <span class="comment">// resulting in a deadlock.  This situation is actually quite plausible because the</span></span><br><span class="line">    <span class="comment">// listener is actually the input dispatcher, which calls into the window manager,</span></span><br><span class="line">    <span class="comment">// which occasionally calls into the input reader.</span></span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文介绍过EventHub的getEvent的大体流程就是:<br>读取每个设备的数据，形成RawEvent结构后放到readBuffer中，如果没有输入事件，将调用epoll_wait()函数阻塞等待</p>
<p>所以InputReaderThread线程大部分时间都是在epoll_wait()上等待，如果某个设备上有事件上来，则唤醒线程，从设备中读取数据，读取到的数据形成RawEvent形式，存放在mEventBuffer中，然后调用processEventsLocked进行处理</p>
<p>下面来看看processEventsLocked这一函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::processEventsLocked(<span class="keyword">const</span> RawEvent* rawEvents, size_t count) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">        int32_t type = rawEvent-&gt;type;</span><br><span class="line">        size_t batchSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;</span><br><span class="line">            int32_t deviceId = rawEvent-&gt;deviceId;</span><br><span class="line">            <span class="keyword">while</span> (batchSize &lt; count) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rawEvent[batchSize].type &gt;= EventHubInterface::FIRST_SYNTHETIC_EVENT</span><br><span class="line">                        || rawEvent[batchSize].deviceId != deviceId) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                batchSize += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">#if DEBUG_RAW_EVENTS</span><br><span class="line">            ALOGD(<span class="string">"BatchSize: %d Count: %d"</span>, batchSize, count);</span><br><span class="line">#endif</span><br><span class="line">            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_ADDED:</span><br><span class="line">                addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::DEVICE_REMOVED:</span><br><span class="line">                removeDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EventHubInterface::FINISHED_DEVICE_SCAN:</span><br><span class="line">                handleConfigurationChangedLocked(rawEvent-&gt;when);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOG_ASSERT(<span class="keyword">false</span>); <span class="comment">// can't happen</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count -= batchSize;</span><br><span class="line">        rawEvent += batchSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的RawEvent分为两类，一类是设备发生变化的Event，包括添加设备，移除设备和扫描设备。另一类是设备自身产生的Event，例如键盘的按键Event，对于这一类Event，会从RawEvent数组中取出连续的同类Event，通过processEventsForDeviceLocked函数进行一并处理，这也是接下来讨论的重点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputReader::processEventsForDeviceLocked(int32_t deviceId,</span><br><span class="line">        <span class="keyword">const</span> RawEvent* rawEvents, size_t count) &#123;</span><br><span class="line">    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">    <span class="keyword">if</span> (deviceIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Discarding event for unknown deviceId %d."</span>, deviceId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputDevice* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">    <span class="keyword">if</span> (device-&gt;isIgnored()) &#123;</span><br><span class="line">        <span class="comment">//ALOGD("Discarding event for ignored deviceId %d.", deviceId);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device-&gt;process(rawEvents, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据传进来的deviceId生成InputDevice对象，关键代码在最后一句，这里调用了InputDevice的process函数<br>frameworks\native\services\inputflinger\InputReader.cpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDevice::process(<span class="keyword">const</span> RawEvent* rawEvents, size_t count) &#123;</span><br><span class="line">    <span class="comment">// Process all of the events in order for each mapper.</span></span><br><span class="line">    <span class="comment">// We cannot simply ask each mapper to process them in bulk because mappers may</span></span><br><span class="line">    <span class="comment">// have side-effects that must be interleaved.  For example, joystick movement events and</span></span><br><span class="line">    <span class="comment">// gamepad button presses are handled by different mappers but they should be dispatched</span></span><br><span class="line">    <span class="comment">// in the order received.</span></span><br><span class="line">    size_t numMappers = mMappers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count--; rawEvent++) &#123;</span><br><span class="line">#if DEBUG_RAW_EVENTS</span><br><span class="line">        ALOGD(<span class="string">"Input event: device=%d type=0x%04x code=0x%04x value=0x%08x when=%lld"</span>,</span><br><span class="line">                rawEvent-&gt;deviceId, rawEvent-&gt;type, rawEvent-&gt;code, rawEvent-&gt;value,</span><br><span class="line">                rawEvent-&gt;when);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDropUntilNextSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">                mDropUntilNextSync = <span class="keyword">false</span>;</span><br><span class="line">#if DEBUG_RAW_EVENTS</span><br><span class="line">                ALOGD(<span class="string">"Recovered from input event buffer overrun."</span>);</span><br><span class="line">#endif</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#if DEBUG_RAW_EVENTS</span><br><span class="line">                ALOGD(<span class="string">"Dropped input event while waiting for next input sync."</span>);</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Detected input event buffer overrun for device %s."</span>, getName().string());</span><br><span class="line">            mDropUntilNextSync = <span class="keyword">true</span>;</span><br><span class="line">            reset(rawEvent-&gt;when);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; numMappers; i++) &#123;</span><br><span class="line">                InputMapper* mapper = mMappers[i];</span><br><span class="line">                mapper-&gt;process(rawEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看这个函数开头的一段注解，大意就是根据不同的Input设备消息调用不同的inputMapper,因为Input设备有很多种，所以Inputmapper也有很多种，这个函数的作用是根据不同的Input设备调用对应的InputMapper的process来处理<br>InputReader.cpp这支文件中有很多不同类型的InputMapper，这里例举其中的KeyboardInputMapper进行说明<br>frameworks\native\services\inputflinger\InputReader.cpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::process(<span class="keyword">const</span> RawEvent* rawEvent) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EV_KEY: &#123; <span class="comment">//按键消息</span></span><br><span class="line">        int32_t scanCode = rawEvent-&gt;code;</span><br><span class="line">        int32_t usageCode = mCurrentHidUsage;</span><br><span class="line">        mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isKeyboardOrGamepadKey(scanCode)) &#123;</span><br><span class="line">            processKey(rawEvent-&gt;when, rawEvent-&gt;value != <span class="number">0</span>, scanCode, usageCode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看processKey这个函数，这个函数比较长</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t scanCode,</span><br><span class="line">        int32_t usageCode) &#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="function">NotifyKeyArgs <span class="title">args</span><span class="params">(when, getDeviceId()</span>, mSource, policyFlags,</span></span><br><span class="line"><span class="function">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span></span><br><span class="line"><span class="function">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, keyMetaState, downTime)</span>;</span><br><span class="line">    getListener()-&gt;notifyKey(&amp;args);</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要工作是将扫描码转换为键盘码，然后调用了getListener()-&gt;notifyKey(&amp;args); </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputListenerInterface* InputReader::ContextImpl::getListener() &#123;</span><br><span class="line">    <span class="keyword">return</span> mReader-&gt;mQueuedListener.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">    mArgsQueue.push(<span class="keyword">new</span> NotifyKeyArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是将args参数放到了mArgsQueue中</p>
<p>往上看最开始的InputReader::loopOnce()中mQueuedListener-&gt;flush();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">    size_t count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        delete args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里和mArgsQueue牵扯上了，这里的flush()函数作用是将mArgsQueue中的NotifyArgs都拿出来，调用它们的notify函数<br>这里还是以Key为例，实际的对象类型是NotifyKeyArgs</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NotifyKeyArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line">    listener-&gt;notifyKey(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的listener指针在构造InputReader是作为参数的，追踪源码得知这一listener实际是指向InputDispatcher的指针</p>
<p>接着看InputDispatcher的notifyKey<br>\frameworks\native\services\inputflinger\InputDispatcher.cpp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line"><span class="comment">//省略部分代码</span></span><br><span class="line">    KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">            flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">            args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"></span><br><span class="line">    mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line"></span><br><span class="line">    bool needWake;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        mLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line">            mLock.unlock();</span><br><span class="line"></span><br><span class="line">            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line">            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// event was consumed by the filter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int32_t repeatCount = <span class="number">0</span>;</span><br><span class="line">        KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里利用函数的参数NotifyKeyArgs创建了KeyEntry对象，然后调用函数enqueueInboundEventLocked将创建好的KeyEntry对象加入到队列中，这里顺便看下enqueueInboundEventLocked函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    bool needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    traceInboundQueueLengthLocked();</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到创建好的KeyEntry对象是被加入到了mInboundQueue队列中去了</p>
<p>自此，读取消息流程分析结束</p>
<hr>
<font color="#000000" size="2" face="楷体">住所，电脑前，汗衫，听着歌，最近有点丧</font>

          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/06/12/Android输入系统系列-2-EventHub/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/12/Android输入系统系列-2-EventHub/" itemprop="url">Android输入系统系列(2)----EventHub</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T22:11:02+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/12/Android输入系统系列-2-EventHub/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/12/Android输入系统系列-2-EventHub/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,286
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上篇文章中说到eventhub是在NativeInputManager的构造函数new出来</p>
<p>一台移动设备能产生输入消息的部件很多，包括键盘，触摸屏，按键等。EventHub的作用就是把所有这些设备产生的消息统一成一种格式，再发往上层进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">        mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">        mNeedToSendFinishedDeviceScan(<span class="keyword">false</span>),</span><br><span class="line">        mNeedToReopenDevices(<span class="keyword">false</span>), mNeedToScanDevices(<span class="keyword">true</span>),</span><br><span class="line">        mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="keyword">false</span>) &#123;</span><br><span class="line">    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line">    <span class="comment">//创建一个epoll句柄</span></span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line">    <span class="comment">//创建一个Inotify对象</span></span><br><span class="line">    mINotifyFd = inotify_init();</span><br><span class="line">    <span class="comment">//监视/dev/input目录变化</span></span><br><span class="line">    <span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">            DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line">    struct epoll_event eventItem;</span><br><span class="line">    memset(&amp;eventItem, <span class="number">0</span>, sizeof(eventItem));</span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.u32 = EPOLL_ID_INOTIFY;</span><br><span class="line">    <span class="comment">//将inotify的句柄加入到epoll的监测中</span></span><br><span class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//创建匿名管道</span></span><br><span class="line">    result = pipe(wakeFds);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//将管道读端和写端设成非阻塞模式</span></span><br><span class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventHub的构造函数首先创建了epoll句柄，然后创建了一个inotify句柄和一个匿名管道，并将inotify的句柄和管道的”读端”句柄都加入到epoll的监测中。</p>
<p>这里说明下inotify的作用<br>inotify是Linux中监视目录和文件变化的一种机制，这里监视的是/dev/input，Andorid中的FileObserver就是封装的inotify，可以直接在java中使用</p>
<p>既然EventHub最终需要将消息传给上层，那么EventHub中的消息又是如何获取的呢？从它的构造函数来看，并没有看到与设备关联的动作。其实是通过EventHub的getEvents()函数  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_t EventHub::getEvents(<span class="keyword">int</span> timeoutMillis, RawEvent* buffer, size_t bufferSize) &#123;</span><br><span class="line">       <span class="comment">//省略部分代码</span></span><br><span class="line">       <span class="keyword">if</span> (mNeedToScanDevices) &#123;</span><br><span class="line">            mNeedToScanDevices = <span class="keyword">false</span>;</span><br><span class="line">            scanDevicesLocked();</span><br><span class="line">            mNeedToSendFinishedDeviceScan = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过mNeedToScanDevices变量控制来判断扫描是否完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventHub::scanDevicesLocked() &#123;</span><br><span class="line">    status_t res = scanDirLocked(DEVICE_PATH);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"scan dir failed for %s\n"</span>, DEVICE_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        createVirtualKeyboardLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了scanDirLocked函数，接着看这个函数做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">status_t EventHub::scanDirLocked(<span class="keyword">const</span> <span class="keyword">char</span> *dirname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> devname[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> *filename;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    struct dirent *de;</span><br><span class="line">    dir = opendir(dirname);</span><br><span class="line">    <span class="keyword">if</span>(dir == NULL)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    strcpy(devname, dirname);</span><br><span class="line">    filename = devname + strlen(devname);</span><br><span class="line">    *filename++ = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">while</span>((de = readdir(dir))) &#123;</span><br><span class="line">        <span class="keyword">if</span>(de-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp;</span><br><span class="line">          (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'\0'</span> ||</span><br><span class="line">            (de-&gt;d_name[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; de-&gt;d_name[<span class="number">2</span>] == <span class="string">'\0'</span>)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        strcpy(filename, de-&gt;d_name);</span><br><span class="line">        openDeviceLocked(devname);</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的参数dirname对应的是DEVICE_PATH，定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *DEVICE_PATH = <span class="string">"/dev/input"</span>;</span><br></pre></td></tr></table></figure></p>
<p>由此可知，scanDirLocked函数的作用是扫描/dev/input目录</p>
<p>我手里的手机上/dev/input目录如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/input # ls</span><br><span class="line">event0 event1 event2 event3 event4 event5 event6</span><br></pre></td></tr></table></figure>
<p>在dev/input下存放的并不是设备，而是event文件，这些event文件对应的设备信息在文件proc/bus/input/devices中可以查到<br>这里贴出其中一个打印片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=<span class="number">0019</span> Vendor=<span class="number">2454</span> Product=<span class="number">6500</span> Version=<span class="number">0010</span></span><br><span class="line">N: Name=<span class="string">"mtk-kpd"</span></span><br><span class="line">P: Phys=</span><br><span class="line">S: Sysfs=/devices/platform/<span class="number">10010000</span>.kp/input/input1</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=gpufreq_ib event1</span><br><span class="line">B: PROP=<span class="number">0</span></span><br><span class="line">B: EV=<span class="number">3</span></span><br><span class="line">B: KEY=<span class="number">140000</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>scanDirLocked函数打开/dev/input目录后，对目录下的每个文件都调用openDeviceLocked()函数<br>看下这个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">status_t EventHub::openDeviceLocked(<span class="keyword">const</span> <span class="keyword">char</span> *devicePath) &#123;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    <span class="comment">// Get device name.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGNAME(sizeof(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get device name for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[sizeof(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.name.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if the device is on our excluded list</span></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mExcludedDevices.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; item = mExcludedDevices.itemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (identifier.name == item) &#123;</span><br><span class="line">            ALOGI(<span class="string">"ignoring event id %s driver %s\n"</span>, devicePath, item.string());</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device driver version.</span></span><br><span class="line">    <span class="keyword">int</span> driverVersion;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGVERSION, &amp;driverVersion)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not get driver version for %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device identifier.</span></span><br><span class="line">    struct input_id inputId;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGID, &amp;inputId)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"could not get device input id for %s, %s\n"</span>, devicePath, strerror(errno));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    identifier.bus = inputId.bustype;</span><br><span class="line">    identifier.product = inputId.product;</span><br><span class="line">    identifier.vendor = inputId.vendor;</span><br><span class="line">    identifier.version = inputId.version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device physical location.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGPHYS(sizeof(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get location for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[sizeof(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.location.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get device unique id.</span></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, EVIOCGUNIQ(sizeof(buffer) - <span class="number">1</span>), &amp;buffer) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//fprintf(stderr, "could not get idstring for %s, %s\n", devicePath, strerror(errno));</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffer[sizeof(buffer) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        identifier.uniqueId.setTo(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数非常长，做的事情主要是打开设备，获取设备的信息包括设备名称，id等。然后根据这些信息判断设备的类型，并根据设备的不同，进行不同的初始化，接着为设备创建一个Device对象。并将设备对象的句柄加入到epoll的监控中。最后调用addDeviceLocked（）函数把Device对象添加到EventHub的mDevices列表中</p>
<hr>
<font color="#000000" size="2" face="楷体">住所，电脑前，汗衫，听着飘洋过海来看你</font>
          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/06/07/Android输入系统系列-1-InputManagerService/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/Android输入系统系列-1-InputManagerService/" itemprop="url">Android输入系统系列(1)----InputManagerService</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T19:42:10+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/07/Android输入系统系列-1-InputManagerService/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/07/Android输入系统系列-1-InputManagerService/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  978
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近项目中遇到事件没有传到上层的问题，虽然问题最终得以解决，不过在问题处理中感知input系统有些东西遗忘了，觉得有必要再拿出完整的梳理一遍，后续将通过系列文章进行梳理，文章借鉴深入理解Android5.0一书，不过后续文章均会基于Android N分析</p>
<p>以下讨论基于<code>Android 7.1.1</code>代码</p>
<p>InputManagerService作为系统服务，启动过程和其他服务流程差不多，在SystemServer中创建<br><code>frameworks\base\services\java\com\android\server\SystemServer.java</code>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Starts a miscellaneous grab bag of stuff that has yet to be refactored</span></span><br><span class="line"><span class="comment">    * and organized.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    InputManagerService inputManager = <span class="keyword">null</span>;</span><br><span class="line">    .....</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartInputManagerService"</span>);</span><br><span class="line">    <span class="comment">//创建InputManagerService对象</span></span><br><span class="line">    inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartWindowManagerService"</span>);</span><br><span class="line">    wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                    !mFirstBoot, mOnlyCore);</span><br><span class="line">     ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">     <span class="comment">//添加到ServiceManager中</span></span><br><span class="line">     ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">     Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">      traceBeginAndSlog(<span class="string">"StartVrManagerService"</span>);</span><br><span class="line">      mSystemServiceManager.startService(VrManagerService.class);</span><br><span class="line">      Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">      mActivityManagerService.setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">      inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">      <span class="comment">//调用了InputManagerService的start方法</span></span><br><span class="line">      inputManager.start();</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了InputManagerService对象，下面看下InputManagerService的构造方法<br><code>frameworks\base\services\core\java\com\android\server\input\InputManagerService.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">        <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">        mUseDevInputEventForAudioJack =</span><br><span class="line">                context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);</span><br><span class="line">        Slog.i(TAG, <span class="string">"Initializing input manager, mUseDevInputEventForAudioJack="</span></span><br><span class="line">                + mUseDevInputEventForAudioJack);</span><br><span class="line">        <span class="comment">//这里调用了InputManagerHandler对象的getLooper()获取主线程的looper后进而调用getQueue()得到消息队列</span></span><br><span class="line">        <span class="comment">//并作为参数传进了nativeInit函数中</span></span><br><span class="line">        mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line"></span><br><span class="line">        String doubleTouchGestureEnablePath = context.getResources().getString(</span><br><span class="line">                R.string.config_doubleTouchGestureEnableFile);</span><br><span class="line">        mDoubleTouchGestureEnableFile = TextUtils.isEmpty(doubleTouchGestureEnablePath) ? <span class="keyword">null</span> :</span><br><span class="line">            <span class="keyword">new</span> File(doubleTouchGestureEnablePath);</span><br><span class="line"></span><br><span class="line">        LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着看nativeinit方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">(InputManagerService service,</span></span></span><br><span class="line"><span class="function"><span class="params">            Context context, MessageQueue messageQueue)</span></span>;</span><br></pre></td></tr></table></figure>
<p>是个native方法，跟着看native层中的实现</p>
<p><code>frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == NULL) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">            messageQueue-&gt;getLooper());</span><br><span class="line">    im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要工作new了一个NativeInputManager对象，下面接着看NativeInputManager的构造函数  </p>
<p><code>frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">        jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mInteractive(<span class="keyword">true</span>) &#123;</span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    mContextObj = env-&gt;NewGlobalRef(contextObj);</span><br><span class="line">    mServiceObj = env-&gt;NewGlobalRef(serviceObj);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">AutoMutex <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;</span><br><span class="line">        mLocked.pointerSpeed = <span class="number">0</span>;</span><br><span class="line">        mLocked.pointerGesturesEnabled = <span class="keyword">true</span>;</span><br><span class="line">        mLocked.showTouches = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInteractive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line">    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要工作: 创建了EventHub对象以及InputManager对象</p>
<p>接着看InputManager的构造函数<br><code>frameworks\native\services\inputflinger\InputManager.cpp</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InputManager::InputManager(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line">    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建了两个对象: InputDispatcher和InputReader，接着调用了initialize()，initialize()中分别new了两个线程: InputReaderThread和InputDispatcherThread，那这两个线程是在什么时机起来的呢?</p>
<p>故事回到了文章开始的地方，InputManagerService创建完之后会调用InputManagerService的start方法，这个start方法中又去调用了nativeStart方法<br><code>frameworks\base\services\core\jni\com_android_server_input_InputManagerService.cpp</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line">    <span class="comment">//注意这里的getInputManager()返回的是一个InputManager对象</span></span><br><span class="line">    status_t result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Input manager could not be started."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里NativeInputManager的getInputManager()返回的是一个InputManager对象，紧接着调用了start方法<br>所以接下来看下InputManager的start方法主要做了啥</p>
<p><code>frameworks\native\services\inputflinger\InputManager.cpp</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">status_t InputManager::start() &#123;</span><br><span class="line">    status_t result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">    result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里启动了InputManager中initialize()创建的InputReaderThread和InputDispatcherThread这两个线程</p>
<p>至此InputManagerService的创建流程讨论完毕，流程还是比较简单的，下文将讨论EventHub</p>
<hr>
<font color="#000000" size="2" face="楷体">住所，电脑前，高考第一天，好紧张</font>

          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/06/06/一个滑动冲突问题的分析流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/一个滑动冲突问题的分析流程/" itemprop="url">一个滑动冲突问题的分析流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T21:58:15+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/06/一个滑动冲突问题的分析流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/06/一个滑动冲突问题的分析流程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,154
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>问题需求</strong><br>原先效果是用户在<code>ViewPager</code>上长按会弹出一个<code>dialog</code>，现在加了一个需求：用户有时候在长按时出现手指向左或向右微小滑动，此时也需要判断为长按并弹出<code>dialog</code></p>
<p><strong>初步分析</strong><br>外边的<code>ViewPager</code>是可以左右滑动的，现在希望单个界面即子<code>view</code>接收到触摸事件后能接管本次事件序列中后续事件，即子<code>View</code>接收到触摸事件后，注意此时手指未松开，所以还处于一次完整的事件序列中，等待一段时间<code>Android</code>默认是<code>400ms</code>后会识别为长按事件，此时子<code>View</code>的长按事件被触发。那么问题来了，怎么才能在子<code>view</code>接收到触摸事件并能接管本次事件序列呢？<br>这就要说到老生常谈的事件拦截了，正常拦截事件有外部拦截和内部拦截两种，这里因为代码中子view已写好现成的手势判断的相关方法，故这里为简单起见，采用内部拦截法来实现。</p>
<p><strong>修改方法</strong><br><code>LauncherPagerAdapter.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> mTouchSlop = <span class="number">40</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        View view = LayoutInflater.from(mContext).inflate(R.layout.launcher_item_layout, <span class="keyword">null</span>);</span><br><span class="line">        ViewGroup parent = (ViewGroup) view.getParent();</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">	<span class="comment">//Add begin</span></span><br><span class="line">        view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">                    <span class="comment">//省略部分代码</span></span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                        <span class="keyword">if</span> (Math.abs(event.getY() - mDownY) &lt;= ((<span class="keyword">float</span>) mTouchSlop) &amp;&amp; Math.abs(event.getX() - mDownX) &lt;= ((<span class="keyword">float</span>) mTouchSlop)) &#123;</span><br><span class="line">                                view.getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>); <span class="comment">//当出现上下左右距离不超过40时，父view不拦截事件, 交给子view</span></span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(event.getX() - mDownX) &gt; ((<span class="keyword">float</span>) mTouchSlop))&#123;</span><br><span class="line">                               view.getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>); <span class="comment">//当出现左右距离超过40时，父view拦截事件并自行消耗</span></span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">	 <span class="comment">//Add end</span></span><br><span class="line">       <span class="comment">//省略部分代码</span></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，再对子<code>view</code>添加长按事件处理，也能顺利的接收到长按事件了。效果上便达到了微小长按滑动也会进入长按事件的处理逻辑中，注意此时微小的向左或向右滑动，<code>viewpager</code>本身并不会移动了，修改之前<code>Viewpager</code>会跟着滑动。</p>
<p>这个问题里用的是内部拦截法，其实也可以自定义<code>Viewpager</code>中重写<code>canScrool()</code>方法，这里就不介绍了，相比而言稍稍麻烦了一点</p>
<p>下面顺便说下滑动冲突的一般解决思路，这是个老生常谈的话题，解决方法已形成固定的流程，需要根据具体的实际业务需求灵活改变。</p>
<p>先介绍几个事件分发处理的几个常见方法<br><code>dispatchTouchEvent</code><br>主要是用来分发事件<br><code>onInterceptTouchEvent</code><br>主要是用来拦截事件的(ViewGroup才有这个方法，View没有这个方法)<br><code>onTouchEvent</code><br>这个方法主要是用来处理事件的<br><code>requestDisallowInterceptTouchEvent(true)</code><br>这个方法能够影响父View是否拦截事件，true 表示父 View 不拦截事件，false 表示父 View 拦截事件</p>
<p><strong>滑动冲突一般解决方法</strong><br>1.外部拦截法<br>一般是通过重写父控件的<code>onInterceptTouchEvent</code>方法，然后根据具体的需求，来决定父控件是否拦截事件。如果拦截返回返回true，不拦截返回false，比如说希望上下滑动不要拦截，那么就在父控件的<code>onInterceptTouchEvent</code>方法里的<code>MotionEvent.ACTION_MOVE</code>这个case块里返回false就好。如果希望指定位置不拦截，则再进行位置判断即可。</p>
<p>对于外部拦截法我们的核心工作一般是做在<code>ACTION_MOVE</code>中，不过需要注意的是不要在<code>ACTION_DOWN</code>中返回 true，这里一旦为true，则同一个事件序列<code>ViewGroup</code>的<code>disPatchTouchEvent</code>就不会再调用<code>onInterceptTouchEvent</code>方法了 。那么本次的事件序列后续都由父view接管，子view对这次事件序列也就没有了机会去消耗事件。归纳起来就是一句话: 父控件一旦拦截了事件，那么同一个事件序列的所有事件都将交给它处理。</p>
<p>2.内部拦截法<br>内部拦截法主要是通过调用父控件的 <code>requestDisallowInterceptTouchEvent</code>方法，传进去一个<code>boolean</code>参数值，true为请求父控件不拦截<br>需要注意的是父控件的<code>onInterceptTouchEvent</code>方法中的<code>ACTION_DOWN</code>事件不要拦截，一旦父控件拦截<code>ACTION_DOWN</code>事件，那么事件无法传递到子元素之中，内部拦截法也就无法起作用了</p>
<p>Good night!</p>
<hr>
<font color="#000000" size="2" face="楷体">住所，晚上，听着歌，洗漱完毕准备休息</font>
          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lihaizhou.top/2018/06/04/月度小结-20180604/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="steven li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李海洲的成长之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/04/月度小结-20180604/" itemprop="url">月度小结--20180604</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-04T21:41:11+08:00">
                2018-06-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/04/月度小结-20180604/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/04/月度小结-20180604/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,374
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>前言</strong><br>本文距个人主页搭建完成已经一个月了，这两年总觉得时间过得真的太快了，一眨眼2018年已经开始进入了下半年。时间的流逝是任何人都无法阻止的，那么就让逝去的光阴多点值得回忆的东西吧</p>
<p><strong>近一个月</strong><br>1.搬家了，坐标从浦东挪到了浦西的闵行，毕业后第一次住在浦西，新的住所很不错，我很喜欢，是毕业至今住的最舒服的住所。到公司也比较近，晚上有时候还可以搭班车回家。室友有一个一岁多的胖猫叫<code>橘子</code>，我喜欢叫<code>胖橘</code>，他很胖不过超级乖，属于那种任人摆布型。<br>2.开始了健身计划，每周三次，周末打打乒乓球，一个多月下来感觉体力明显比之前好一些，精力更充沛了。<br>3.开始每周更新笔记，记录工作中的一些问题的分析流程，厘清的过程加深理解。  </p>
<p>工作至今，发现一个现象，与不同类型的同事协作开发，会有不同的体验，大体遇到如下几类：</p>
<p>1.技术能力强，做事积极，态度和蔼，同这种同事共事往往会比较舒服，不仅仅是协作开发效率会比较高。更重要的是，这类同事做事比较有保障，做事方式有条理，沉着冷静。对于问题的解决，会慢慢厘清，最后会输出清晰有效的解决方案。这类型同事往往懂得技术积累，懂得提升自己。同这样的同事协作开发的话，不仅仅身心愉悦，往往会对自己产生一种正面的影响。</p>
<p>2.技术薄弱，做事积极，容易慌乱，这里指工作两年以上的同事，遇到过很多或多或少存在遇事慌乱，缺乏条理性，将问题当作一种负担看待，遇事急于解决或将问题抛出去，问题的结果往往不尽如人意，见过不少同事遇到出现应用异常，第一反应就是上去不管三七二十一直接<code>try-catch</code>起来，让人哭笑不得，同这样的同事协作开发的话，会比较尴尬。</p>
<p>3.技术薄弱，做事无厘头，这类同事在分析问题上比较跳跃，遇问题急于上网查询答案，所做的简单需求往往一堆bug，代码没有规范可言，这类同事如果刚毕业能够理解，后面有矫正的机会。工作至今，遇到过一些工作几年的同事也是如此，比较令人费解。同这样的同事协作开发的话，会比较尴尬。</p>
<p>4.技术一般，做事激进，这类同事做事比较风风火火，遇事不退缩，急于在最短时间内解决掉，仿佛问题的存在就是定时炸弹，这类同事做起事来比较高调，加班也比较猛，往往深得领导喜欢。但其实仔细观察下来，问题的解决速度是很快，但方案往往不是最优，很多时候埋了一些坑进去。同这样的同事协作开发的话，总觉得不太靠谱。</p>
<p>5.技术一般，做事稳当，这类同事能够应付平时的日常需求开发，遇到棘手问题，往往难以梳理清楚并解决，做事完全是以完成为目标，不太会去主动想办法提升个人能力，这类型同事比较常见，同这样的同事协作开发的话，一般项目进度不成问题。</p>
<p>6.技术尚可，做事圆滑，这类同事一般在公司工作有些年头，头衔较高，对应的薪水也比较高，遇事不会慌乱，态度也比较和蔼，就是在问题的解决上不会完全投入，属于能拖则拖，能给芯片商比如联发科高通分析的，决不自己分析，平时比较低调，属于混日子型，同这类同事协作开发往往只能在一旁干着急。</p>
<p>今后的日子里，努力像第一类同事学习并努力成为这样的人</p>
<p><strong>一点闲话</strong><br>渐渐的发现，呆在一个环境时间久了，会容易受到周围环境以及身边同事的做事方式影响，会慢慢被同化，现在相信一个公司对人的塑造是多少会有影响的，可能是好的方向，也可能是不好的方向。<br>就我个人而言，我觉得自己并不是一个自我驱动力很强的人，倘若处在一个很安逸没有挑战的环境中，必然会变得懒散，不思进取。可能会在某个周末的清晨大梦初醒一般，开始懊悔虚度年华，于是立马像打了鸡血一般，猛立目标并付诸行动，一个礼拜后发现还是虚度年华舒服啊，于是计划不了了之了。<br>这次与以往不同的是，以笔记的形式记录下来，逼迫自己坚持下来，但愿能够一直保持。  </p>
<p>谨以此文，与君共勉</p>
<p>Come on! Steven!</p>
<p>最后附一张胖橘照片<br><img src="https://github.com/hellolihaizhou/hellolihaizhou.github.io/blob/master/2018/06/04/%E6%9C%88%E5%BA%A6%E5%B0%8F%E7%BB%93-20180604/pangju.jpg?raw=true" align="left" style=" width:300px;height:80 px"> <br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<hr>
<font color="#000000" size="2" face="楷体">住所，电脑前，听着罗大佑的恋曲1990，惬意</font>
          
        
      
    </div>
    
    
    
	
	<div>
	  
    </div>
	
    
	
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/background.jpg"
                alt="steven li" />
            
              <p class="site-author-name" itemprop="name">steven li</p>
              <p class="site-description motion-element" itemprop="description">Nothing for nothing</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">steven li</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>




  <span class="post-meta-divider">|</span>





<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">Steven的博客共29.5k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Hsz9zOlrvMN9ry0R9Jfi5ykJ-gzGzoHsz',
        appKey: 'MAHOS3RIF7wDFRbEeC7kf3Vr',
        placeholder: '此处输入评论内容',
        avatar:'wavatar',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
