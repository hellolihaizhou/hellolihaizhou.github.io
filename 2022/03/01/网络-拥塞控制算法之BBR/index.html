<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->


    

<!-- keywords -->



<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="Steven Li">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Steven Li">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="愿历尽千帆 归来仍少年">
    <meta name="description" content="写在前面最近周末，打算将之前看过的BBR论文拿出来重新啃一遍，这次阅读后有了一些新的理解，所以打算记录下来。以便以后回顾完善。 Bufferbloat在讨论BBR之前不得不说下Bufferbloat，在BBR之前的拥塞控制算法无一例外都和网络缓存耦合在了一起，所以都会存在发生Bufferbloat的情况。 关于bufferbloat的定义  缓冲膨胀是一种因数据包过度缓冲而引起的数据包交换网络高延">
<meta property="og:type" content="article">
<meta property="og:title" content="网络 | 拥塞控制算法之BBR">
<meta property="og:url" content="http://lihaizhou.top/2022/03/01/网络-拥塞控制算法之BBR/index.html">
<meta property="og:site_name" content="李海洲">
<meta property="og:description" content="写在前面最近周末，打算将之前看过的BBR论文拿出来重新啃一遍，这次阅读后有了一些新的理解，所以打算记录下来。以便以后回顾完善。 Bufferbloat在讨论BBR之前不得不说下Bufferbloat，在BBR之前的拥塞控制算法无一例外都和网络缓存耦合在了一起，所以都会存在发生Bufferbloat的情况。 关于bufferbloat的定义  缓冲膨胀是一种因数据包过度缓冲而引起的数据包交换网络高延">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.lihaizhou.top/BBR/BBR_1.png">
<meta property="og:image" content="http://blog.lihaizhou.top/BBR/BBR_2.png">
<meta property="og:image" content="http://blog.lihaizhou.top/BBR/BBR_3.png">
<meta property="og:image" content="http://blog.lihaizhou.top/BBR/BBR_4.png">
<meta property="og:image" content="http://blog.lihaizhou.top/BBR/BBR_5.png">
<meta property="og:updated_time" content="2022-04-14T08:39:07.882Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络 | 拥塞控制算法之BBR">
<meta name="twitter:description" content="写在前面最近周末，打算将之前看过的BBR论文拿出来重新啃一遍，这次阅读后有了一些新的理解，所以打算记录下来。以便以后回顾完善。 Bufferbloat在讨论BBR之前不得不说下Bufferbloat，在BBR之前的拥塞控制算法无一例外都和网络缓存耦合在了一起，所以都会存在发生Bufferbloat的情况。 关于bufferbloat的定义  缓冲膨胀是一种因数据包过度缓冲而引起的数据包交换网络高延">
<meta name="twitter:image" content="http://blog.lihaizhou.top/BBR/BBR_1.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
        <link rel="alternate" href="/atom.xml" title="愿历尽千帆 归来仍少年" type="application/atom+xml">
    
    <title>网络 | 拥塞控制算法之BBR · 李海洲</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20210823" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20210823" as="style">
    <link rel="stylesheet" href="/css/dark.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/css/mobile.css?v=20210823" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20210823" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20210823" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin="">
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin="">
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>愿历尽千帆 归来仍少年</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">愿历尽千帆 归来仍少年</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">网络 | 拥塞控制算法之BBR</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                网络 | 拥塞控制算法之BBR
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">5,873</span>阅读时长: <span class="post-count reading-time">23 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2022/03/01</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近周末，打算将之前看过的BBR论文拿出来重新啃一遍，这次阅读后有了一些新的理解，所以打算记录下来。以便以后回顾完善。</p>
<h4 id="Bufferbloat"><a href="#Bufferbloat" class="headerlink" title="Bufferbloat"></a>Bufferbloat</h4><p>在讨论BBR之前不得不说下Bufferbloat，在BBR之前的拥塞控制算法无一例外都和网络缓存耦合在了一起，所以都会存在发生Bufferbloat的情况。</p>
<p><strong>关于bufferbloat的定义</strong></p>
<blockquote>
<p>缓冲膨胀是一种因数据包过度缓冲而引起的数据包交换网络高延迟原因。缓冲膨胀还可能导致数据包延迟变化（也称为抖动），并降低整体网络吞吐量。当路由器或交换机配置了过大的缓冲区时，对于许多交互式应用程序，例如IP语音（VoIP），在线游戏，甚至普通的网页浏览，即使是非常高速的网络也几乎无法使用。<br>一些通信设备制造商在他们的某些网络产品中不必要地设计了过大的缓冲区。在这种设备中，当网络链路拥塞时，就会发生缓冲膨胀，从而导致数据包在这些超大缓冲区中长时间排队。在先进先出队列系统中，过大的缓冲区会导致更长的队列和更高的延迟，并且不会提高网络吞吐量。</p>
</blockquote>
<p>(摘自维基百科)</p>
<p>因为大多数的拥塞控制算法都是基于丢包来测算带宽，有丢包发生后便会降低传输速率，如果中间路由设备引入大的缓冲区会出现什么现象呢？<br>虽然丢包会减少，但是延迟会上升，我们可以想象一个极端情况下的场景：假设中间路由设备的Buffer设定的无穷大，大到不管发送端发送的速率有多快，这个buffer都能放得下，这样的话就没有丢包发生了，但是会造成延迟也会上升到一个非常糟糕的情况。</p>
<p>那么bufferbloat是网络设备商有意为之的吗？其实是时代变迁下的妥协</p>
<p>我们有必要先了解下bufferbloat出现的历史缘由</p>
<blockquote>
<p>在以前的互联网上，交换机可能总是拥有比服务器更快的网卡，所以这些位于互联网中间层的服务器也可能比客户端更快，并且并不能对客户端发送信息包的速率有多大影响。<br>很显然今天已经不是这样的了！众所周知，今天的计算机相比于 5 年前的计算机在速度上并没有多大的提升（我们遇到了某些有关光速的问题）。所以我想路由器上的大型交换机并不会在速度上大幅领先于数据中心里服务器上的网卡。</p>
</blockquote>
<p>(摘自Van Jacobson的netdev演讲)</p>
<p>个人对上面这段话的理解是：<br>早期终端设备和网络核心交换设备性能上存在明显的悬殊，像思科这类厂商，他们的中间路由设备的处理能力是能够吊打一众终端设备的。所以这个时期，中间设备的缓存显得不那么重要，可能只需很少的缓存就够用了，对于终端设备而言，只需要考虑发送的尽可能的快就行！<br>随着时代的发展，终端处理器以及网卡性能的不断提升，不断缩小了和中间转发设备性能上的差距，这个时候问题就出现了: 中间转发设备似乎不太来得及处理数据包了，那么这个时候该怎么解决呢？<br>需要想办法尽快解决没有来得及处理的数据包，提升处理器的性能或者增加处理器都是办法，但是这些办法都没有引入一个大缓存来的有性价比。<br>其实这违背了中间转发设备本身的角色定位，它的角色应该只是转发，而不应该成为一个缓存设备！</p>
<p>对于Bufferbloat，你可以唾弃它，可以鄙视它，但是它却是时代变迁下”不得已”的产物。</p>
<h4 id="BBR-原理"><a href="#BBR-原理" class="headerlink" title="BBR 原理"></a>BBR 原理</h4><p>BBR算法的诞生，可以说是拥塞控制算法的分界点，为什么这样说呢？<br>在BBR诞生前的如Reno/Cubic等算法都是事件驱动，所以是一种被动的模型，一旦有丢包或RTT增加，即便不是真的拥塞导致的RTT增加，也会导致发送速率的下降。<br>然而BBR的窗口调整是主动的行为，有点像轮询，不同的是BBR的这种”轮询”是基于事实反馈的。<br>还有一个最大的不同之处就是：<br>BBR不会贪婪的使用缓存，会尽可能少的占用或者不用缓存，这样的话就可以避免产生我们上面说的bufferbloat现象，这是一个非常了不起的变革点。</p>
<p>关于BBR的诞生缘由</p>
<blockquote>
<p>These problems result from a design choice made when TCP congestion control was created in the 1980s—interpreting packet loss as “congestion.”13 This equivalence was true at the time but was because of technology limitations, not first principles. As NICs (network interface controllers) evolved from Mbps to Gbps and memory chips from KB to GB, the relationship between packet loss and congestion became more tenuous.<br>Today TCP’s loss-based congestion control—even with the current best of breed, CUBIC11—is the primary cause of these problems. When bottleneck buffers are large, loss-based congestion control keeps them full, causing bufferbloat. When bottleneck buffers are small, loss-based congestion control misinterprets loss as a signal of congestion, leading to low throughput. Fixing these problems requires an alternative to loss-based congestion control. Finding this alternative requires an understanding of where and how network congestion originates.</p>
</blockquote>
<p>(摘自BBR论文&lt;BBR: Congestion-Based Congestion Control&gt;)</p>
<p>简单的理解就是基于丢包的拥塞控制算法，在缓冲区缓存比较大的时候，会使得缓冲区被填满最终造成bufferbloat。而当缓冲区缓存较小时，基于丢包的拥塞算法可能会误判为此时网络拥塞，并降低吞吐量，所以要想解决这种问题，就需要找到一种不是基于丢包的拥塞控制算法。<br>于是，BBR 诞生了。</p>
<p>在讲解BBR之前，先了解几个参数名词，这几个名词会贯穿本文</p>
<ol>
<li>RTprop（Round-trippropagation time）：最小时延，一个来回所以其实是两倍时延</li>
<li>BtlBw（bottleneck bandwidth）：瓶颈带宽</li>
<li>BDP = BtlBw * RTprop：整条链路所能存储的数据值(不含路由缓存)</li>
<li>BtlBufSize ：链路上所有的中间路由缓存之和<br>BBR论文中对两者关系用了一个比喻来说明<br>If the network path were a physical pipe, RTprop would be its length and BtlBw its minimum diameter.<br>其实根据这个定义，我们很容易想到：<br>如果当前的实际发送速率乘以延迟得到的值越接近 BDP 说明算法的效率越高。</li>
</ol>
<p>下图是这几个参数之间的关系<br><img src="http://blog.lihaizhou.top/BBR/BBR_1.png" alt=""><br>(这张图原图摘自BBR论文，笔者加了一些自己的理解在上面)</p>
<p>个人理解</p>
<ol>
<li>数据刚开始传输时，这个时候显然数据量未填充满也就是未达到BDP，此时传输速率持续上升，RTT处于最优状态也就是最小时延，这是一个传输通畅的阶段。</li>
<li>当数据填充超过BDP时，数据会使用到路由的缓存区，这个时候RTT会开始上升，但是发送速率还维持不变，这个阶段处于一个缓冲阶段，一旦越过BDP分界线就说明拥塞开始出现了。</li>
<li>当数据填充超过（BDP+BtlBufSize）大小后，此时没有地方能够存储下没有来得及发送的数据，丢包开始产生！关于图中笔者标记出来的丢包临界点，基于丢包的拥塞算法几乎都是以此为收敛点，尽可能的填充满网络和缓存，认为此举是可以提高网络利用率和减少丢包，一旦出现丢包，就开始降低数据的发送量并再次向这个错误的收敛靠近。<br>BBR的目标收敛点都是围绕着图中理想收敛点位置，而基于丢包的cubic/Reno等算法都是围绕着如何收敛到丢包临界点上，因为它们总是将缓存考虑在内，这其实是一个错误的做法。BBR</li>
</ol>
<p>关于图中的斜率，个人理解如下：<br>假设某一时刻实际发送数据大小为S，实际带宽为R，R必定是 &lt;= BtlBw，实际时延设为<code>T&gt;=RTprop</code>。<br>这一时刻的数据量 S=T*R， 所以这里<code>T/S = 1/R &gt;= 1/BtlBw</code>，所以实际情况下斜率往往是比上半图中的更陡峭，同理下半图的斜率 R/S = 1/T &lt;= 1/RTprop，所以实际情况下下半图的斜率往往会更平缓些，图中的阴影部分是不可达的。</p>
<p>关于发送速率的计算方式，BBR论文中是这样解释的</p>
<blockquote>
<p>Unlike RTT, nothing in the TCP spec requires implementations to track bottleneck bandwidth, but a good estimate results from tracking delivery rate. When the ack for some packet arrives back at the sender, it conveys that packet’s RTT and announces the delivery of data inflight when that packet departed. Average delivery rate between send and ack is the ratio of data delivered to time elapsed: deliveryRate = Δdelivered/Δt. This rate must be ≤ the bottleneck rate (the arrival amount is known exactly so all the uncertainty is in the Δt, which must be ≥ the true arrival interval; thus, the ratio must be ≤ the true delivery rate, which is, in turn, upper-bounded by the bottleneck capacity). </p>
</blockquote>
<p>简单理解为</p>
<ol>
<li>应答了多少数据，记为delivered；</li>
<li>应答delivered这么多数据所用时间，记为interval_us。<br>将上述二者相除，就能得到带宽：bw = delivered/interval_us</li>
</ol>
<p>从前面那张图我们可以发现，如果测量BtlBw则需要填满buffer，测量RTprop 需要排空buffer也就是不能使用buffer，所以BBR的BtlBw和RTprop无法同时测量的。<br>那么BBR是怎么做得呢？下面会结合源码分别进行分析</p>
<h5 id="Startup"><a href="#Startup" class="headerlink" title="Startup"></a>Startup</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use a high_gain value of 2/ln(2) because it's the smallest pacing gain</span></span><br><span class="line"><span class="comment"> * that will allow a smoothly increasing pacing rate that will double each RTT</span></span><br><span class="line"><span class="comment"> * and send the same number of packets per RTT that an un-paced, slow-starting</span></span><br><span class="line"><span class="comment"> * Reno or CUBIC flow would:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> bbr_high_gain  = BBR_UNIT * <span class="number">2885</span> / <span class="number">1000</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个值主要用于计算<code>pacing_rate</code>，至于这个初始值为何是2/ln(2)这样一个写死的值，笔者翻阅了BBR论文并找到没有提及原因的地方，猜测可能是实测算出的最优值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize pacing rate to: high_gain * init_cwnd / RTT. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bbr_init_pacing_rate_from_rtt</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bbr</span> *<span class="title">bbr</span> = <span class="title">inet_csk_ca</span>(<span class="title">sk</span>);</span></span><br><span class="line">        u64 bw;</span><br><span class="line">        u32 rtt_us;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;srtt_us) &#123;                <span class="comment">/* any RTT sample yet? */</span></span><br><span class="line">                rtt_us = max(tp-&gt;srtt_us &gt;&gt; <span class="number">3</span>, <span class="number">1U</span>);</span><br><span class="line">                bbr-&gt;has_seen_rtt = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                         <span class="comment">/* no RTT sample yet */</span></span><br><span class="line">                rtt_us = USEC_PER_MSEC;         <span class="comment">/* use nominal default RTT */</span></span><br><span class="line">        &#125;</span><br><span class="line">        bw = (u64)tp-&gt;snd_cwnd * BW_UNIT;</span><br><span class="line">        do_div(bw, rtt_us);</span><br><span class="line">        sk-&gt;sk_pacing_rate = bbr_bw_to_pacing_rate(sk, bw, bbr_high_gain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Startup阶段，pacing_rate在每次收到一个ACK后，都会提高bbr_high_gain的值。<br>BBR计算拥塞窗口是用“当前采集到的速率”乘以“当前采集到的最小RTT”来计算的，这就造成了“当前发送窗口”和“当前已经提高的速率”之间的不匹配，所以，计算拥塞窗口的时候，gain因子也必须是bbr_high_gain，从而可以吸收掉速率的实际提升.</p>
<h5 id="ProbeRTT"><a href="#ProbeRTT" class="headerlink" title="ProbeRTT"></a>ProbeRTT</h5><p>到这里，我们知道要想达到理想收敛点，就需要找到最小时延和瓶颈带宽<br>我们先来讨论下BBR是如何找到最小RTT的<br>如果了解过Vegas算法原理的人，应该知道Vegas对时延的波动比较敏感，即便一次不是真的拥塞导致的RTT增加都会导致其降窗。<br>那么BBR是基于时延找最小RTT的吗？并不是，下面会讲述</p>
<p>最小RTT的有效时间是10s<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Window length of min_rtt filter (in sec): */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 bbr_min_rtt_win_sec = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/* Minimum time (in ms) spent at bbr_cwnd_min_target in BBR_PROBE_RTT mode: */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 bbr_probe_rtt_mode_ms = <span class="number">200</span>;</span><br></pre></td></tr></table></figure></p>
<p>探测最小RTT需要最少4个数据包，这是为了兼顾延迟ACK。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to keep at least this many packets in flight, if things go smoothly. For</span></span><br><span class="line"><span class="comment"> * smooth functioning, a sliding window protocol ACKing every other packet</span></span><br><span class="line"><span class="comment"> * needs at least 4 packets in flight:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 bbr_cwnd_min_target = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>更新最小RTT核心函数 bbr_update_min_rtt，这个函数较长，我们将其拆分开来进行讨论</p>
<p>1.如果本次RTT时间小于最小RTT时间值或者最小RTT时间有效时间到了，则更新最小RTT值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Track min RTT seen in the min_rtt_win_sec filter window: */</span></span><br><span class="line">  filter_expired = after(tcp_jiffies32,</span><br><span class="line">                         bbr-&gt;min_rtt_stamp + bbr_min_rtt_win_sec * HZ);</span><br><span class="line">  <span class="keyword">if</span> (rs-&gt;rtt_us &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (rs-&gt;rtt_us &lt; bbr-&gt;min_rtt_us ||</span><br><span class="line">       (filter_expired &amp;&amp; !rs-&gt;is_ack_delayed))) &#123;</span><br><span class="line">          bbr-&gt;min_rtt_us = rs-&gt;rtt_us;</span><br><span class="line">          bbr-&gt;min_rtt_stamp = tcp_jiffies32;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>2.最小RTT时间过期了且当前未处于PROBE_RTT模式，则切换模式到RTT，降低发送速率<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bbr_probe_rtt_mode_ms &gt; <span class="number">0</span> &amp;&amp; filter_expired &amp;&amp;</span><br><span class="line">       !bbr-&gt;idle_restart &amp;&amp; bbr-&gt;mode != BBR_PROBE_RTT) &#123;</span><br><span class="line">           bbr-&gt;mode = BBR_PROBE_RTT;  <span class="comment">/* dip, drain queue */</span></span><br><span class="line">           bbr_save_cwnd(sk);  <span class="comment">/* note cwnd so we can restore it */</span></span><br><span class="line">           bbr-&gt;probe_rtt_done_stamp = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>3.如果此时处于<code>PROBE_RTT</code>模式下，首先设置app_limited 是为了表面这个时间区域内BW参与最大值计算。inflight数据包小于等于<code>bbr_cwnd_min_target</code>即四个数据包时，同时满足一些其它条件后，开始更新本次最小RTT侦测结束时间戳，也就是当前时间加上200ms，并将本次已delivered数据赋值给下个RTT。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bbr-&gt;mode == BBR_PROBE_RTT) &#123;</span><br><span class="line">               <span class="comment">/* Ignore low rate samples during this mode. */</span></span><br><span class="line">               tp-&gt;app_limited =</span><br><span class="line">                       (tp-&gt;delivered + tcp_packets_in_flight(tp)) ? : <span class="number">1</span>;</span><br><span class="line">               <span class="comment">/* Maintain min packets in flight for max(200 ms, 1 round). */</span></span><br><span class="line">               <span class="keyword">if</span> (!bbr-&gt;probe_rtt_done_stamp &amp;&amp;</span><br><span class="line">                   tcp_packets_in_flight(tp) &lt;= bbr_cwnd_min_target) &#123;</span><br><span class="line">                       bbr-&gt;probe_rtt_done_stamp = tcp_jiffies32 +</span><br><span class="line">                               msecs_to_jiffies(bbr_probe_rtt_mode_ms);</span><br><span class="line">                       bbr-&gt;probe_rtt_round_done = <span class="number">0</span>;</span><br><span class="line">                       bbr-&gt;next_rtt_delivered = tp-&gt;delivered;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bbr-&gt;probe_rtt_done_stamp) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (bbr-&gt;round_start)</span><br><span class="line">                               bbr-&gt;probe_rtt_round_done = <span class="number">1</span>;</span><br><span class="line">                       <span class="keyword">if</span> (bbr-&gt;probe_rtt_round_done)</span><br><span class="line">                               bbr_check_probe_rtt_done(sk);</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ProbeBW"><a href="#ProbeBW" class="headerlink" title="ProbeBW"></a>ProbeBW</h5><p>增益系数数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The pacing_gain values for the PROBE_BW gain cycle, to discover/share bw: */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> bbr_pacing_gain[] = &#123;</span><br><span class="line">        BBR_UNIT * <span class="number">5</span> / <span class="number">4</span>,        <span class="comment">/* probe for more available bw */</span></span><br><span class="line">        BBR_UNIT * <span class="number">3</span> / <span class="number">4</span>,        <span class="comment">/* drain queue and/or yield bw to other flows */</span></span><br><span class="line">        BBR_UNIT, BBR_UNIT, BBR_UNIT, <span class="comment">/* cruise at 1.0*bw to utilize pipe, */</span></span><br><span class="line">        BBR_UNIT, BBR_UNIT, BBR_UNIT  <span class="comment">/* without creating excess queue... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>bbr_pacing_gain[0]<br>这个阶段gain的值是1.25，也是BBR的初始值，这个阶段意味着BBR会试图增加发送量，尽可能多的占用带宽，占满新进的多余的带宽，目的是提升资源的利用率，不过这个阶段可能会出现队列的产生以及RTT变长的情况。<br>bbr_pacing_gain[0]退出条件时：<br>已经运行超过了一个最小RTT时间并且要么发生了丢包，要么本次ACK到来前的inflight的值已经等于窗口值了。[引用2]</li>
<li>bbr_pacing_gain[1]<br>bbr_pacing_gain[1] 这个阶段gain的值为0.75，假设此时正处于增益阶段，此时一个新的连接发起，可能会导致正处于增益阶段的连接的inflight满载，这个时候就需要切换到bbr_pacing_gain[1] 状态，在出让部分带宽后尽快进入平稳期，这个阶段体现了BBR的公平性。<br>这个阶段时间较短，一旦完成出让带宽就退出，最多停留不超过一个最短RTT时间。</li>
<li>bbr_pacing_gain[2]…. bbr_pacing_gain[7]<br>这个阶段代表的是平稳期，至少停留6个RTT</li>
</ol>
<p>进入<code>PROBE_BW</code>状态后会反复的在上面三个步骤之间循环：加速、减速、匀速。。。。<br><img src="http://blog.lihaizhou.top/BBR/BBR_2.png" alt=""><br>(图片摘自BBR论文，笔者加了些理解) </p>
<p>这个时候，设想下如果上面的数组中移除掉后面的六个元素，也就是移除平稳期，会出现什么样的情况呢？<br>因为一旦进入平稳期由于至少停留6个RTT的限制，导致在这期间如果有富余带宽，BBR是无法抢占的，所以如果一旦移除到平稳期，带来的就是更快的发现富余带宽，代价就是比较网络比较颠簸，对于一些如下载类的业务有益，不适用于如直播类业务。</p>
<p>关于bbr_pacing_gain增益数组的作用，归纳下来就是：<br><code>BBR会尽可能的抢占更多带宽，一旦有了新的连接之后，如果出现本次窗口估值等于上次的inflight值，说明这个时候带宽被填满了。
此时旧连接的gain值下降进而让出部分带宽给新连接，在至少6个RTT周期内也就是平稳期，这个阶段旧连接不会抢占更多带宽，直到6个RTT后，旧连接会试图抢占更多带宽，周而复始。</code></p>
<p>bbr_update_bw 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Estimate the bandwidth based on how fast packets are delivered */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bbr_update_bw</span><span class="params">(struct sock *sk, <span class="keyword">const</span> struct rate_sample *rs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bbr</span> *<span class="title">bbr</span> = <span class="title">inet_csk_ca</span>(<span class="title">sk</span>);</span></span><br><span class="line">        u64 bw;</span><br><span class="line"></span><br><span class="line">        bbr-&gt;round_start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (rs-&gt;delivered &lt; <span class="number">0</span> || rs-&gt;interval_us &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">/* Not a valid observation */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* See if we've reached the next RTT */</span></span><br><span class="line">        <span class="keyword">if</span> (!before(rs-&gt;prior_delivered, bbr-&gt;next_rtt_delivered)) &#123;</span><br><span class="line">                bbr-&gt;next_rtt_delivered = tp-&gt;delivered;</span><br><span class="line">                bbr-&gt;rtt_cnt++;</span><br><span class="line">                bbr-&gt;round_start = <span class="number">1</span>;</span><br><span class="line">                bbr-&gt;packet_conservation = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bbr_lt_bw_sampling(sk, rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Divide delivered by the interval to find a (lower bound) bottleneck</span></span><br><span class="line"><span class="comment">         * bandwidth sample. Delivered is in packets and interval_us in uS and</span></span><br><span class="line"><span class="comment">         * ratio will be &lt;&lt;1 for most connections. So delivered is first scaled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//计算当前实际带宽</span></span><br><span class="line">        bw = div64_long((u64)rs-&gt;delivered * BW_UNIT, rs-&gt;interval_us);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this sample is application-limited, it is likely to have a very</span></span><br><span class="line"><span class="comment">         * low delivered count that represents application behavior rather than</span></span><br><span class="line"><span class="comment">         * the available network rate. Such a sample could drag down estimated</span></span><br><span class="line"><span class="comment">         * bw, causing needless slow-down. Thus, to continue to send at the</span></span><br><span class="line"><span class="comment">         * last measured network rate, we filter out app-limited samples unless</span></span><br><span class="line"><span class="comment">         * they describe the path bw at least as well as our bw model.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * So the goal during app-limited phase is to proceed with the best</span></span><br><span class="line"><span class="comment">         * network rate no matter how long. We automatically leave this</span></span><br><span class="line"><span class="comment">         * phase when app writes faster than the network can deliver :)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//加入新的样本</span></span><br><span class="line">        <span class="keyword">if</span> (!rs-&gt;is_app_limited || bw &gt;= bbr_max_bw(sk)) &#123;</span><br><span class="line">                <span class="comment">/* Incorporate new sample into our max bw filter. */</span></span><br><span class="line">                minmax_running_max(&amp;bbr-&gt;bw, bbr_bw_rtts, bbr-&gt;rtt_cnt, bw);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要做的事比较清晰，主要是更新RTT周期、通过已delivered数据 * BW_UNIT/采样时间得出带宽值，并将带宽和min rtt加入到新的RTT和BW样本。</p>
<p>通过对<code>ProbeRTT</code>和<code>ProbeBW</code>的分析，可以知道BBR其实大部分时候都是在ProbeBW和ProbeRTT状态之间切换，并且绝大部分时间是停留在ProbeBW上。<br>根据代码可以得到如下一个简要的图：<br><img src="http://blog.lihaizhou.top/BBR/BBR_3.png" alt=""></p>
<p>可以看出大部分时候都停留在<code>ProbeBW</code>上，在<code>ProbeRTT</code>停留的时间很短，这其实符合BBR的初衷：尽可能的多占用带宽并且尽量不占用缓存。</p>
<p>根据前面的代码梳理，画了一张状态机的流转图<br><img src="http://blog.lihaizhou.top/BBR/BBR_4.png" alt=""><br>如果我们用一个精简的图来看这个过程的话，大致如下<br><img src="http://blog.lihaizhou.top/BBR/BBR_5.png" alt=""></p>
<h4 id="BBR-优缺点"><a href="#BBR-优缺点" class="headerlink" title="BBR 优缺点"></a>BBR 优缺点</h4><p>从前面的讨论中，我们知道BBR的优势，也不难发现其劣势。</p>
<h5 id="BBR-优势"><a href="#BBR-优势" class="headerlink" title="BBR 优势"></a>BBR 优势</h5><p>1.在长传即大RTT场景下优势明显<br>有一种典型的场景便是”长肥管道”，在TCP连接中，较长的距离意味着RTT的增加，进而意味着窗口打开的更慢，对于像Cubic这类AIMD的拥塞算法而言，它们的慢启动过程会越长 ，这就是Reno家族算法的典型弊端。<br>另外，对于Cubic这类算法而言，更容易出现缓冲区被占满的情况，也就是我们前面提到的bufferbloat，这是为何呢？<br>一窗数据只有在得到ACK确认后才会清除，RTT越小意味着缓冲区能够越快腾出空间，发生bufferbloat概率也越低。反之RTT越大的话，越容易出现bufferbloat的情形<br>而BBR设计之初，就没有将中间缓存考虑在内，从本文前面的收敛图可以看出</p>
<ul>
<li>BBR的理想带宽收敛点是在缓冲区即将被填充的时候，此时BtlBW最大，RTT最小</li>
<li>而对于Reno家族算法而言，其收敛点是缓冲区被填满的时候，此时BtlBW最大，但RTT也最大。</li>
</ul>
<p>归纳下来：<br>对于长肥管道这种场景，Cubic这类传统算法表现会异常脆弱，一旦有丢包立马械 投降，执行MD     过程，这个过程是一个快速降窗的过程，前功尽弃。<br>而BBR的优势在于不会导致bufferbloat，且对丢包不敏感使得其不会出现激进降窗的行为。</p>
<p>2.抢占带宽能力强<br>BBR其实大部分时候都是在ProbeBW和ProbeRTT状态之间切换，并且绝大部分时间是停留在ProbeBW上。ProbeBW阶段会不断的试探剩余可用带宽，短时间内占据更多的带宽。</p>
<p>3.平稳发送<br>由于其平稳期至少待够6个RTT周期才行，这使得该阶段的发送速率比较平稳，比较适合音视频领域比如视频直播这种对稳定性要求较高的场景。</p>
<h5 id="BBR-不足之处"><a href="#BBR-不足之处" class="headerlink" title="BBR 不足之处"></a>BBR 不足之处</h5><p>1.对带宽变化不敏感<br>从前面原理分析环节，我们知道BBR减损期会让出部分带宽，一旦这个时候被其它流占据了话，BBR要等到度过本地”漫长”的平稳期，等到下个增益周期才能发现。<br>也就是说BBR在ProbeBW状态下，只有在ProbeMore周期才能感受到带宽的变化，后面的ProbeDrain以及平稳期对于带宽的变化都无法感知，如果这个阶段实际带宽降低，BBR需要多个RTT周期才能收敛到实际的带宽位置。</p>
<p>2.ProbeRTT阶段导致发送速率下降太多<br>这个阶段由于只发四个包，导致发送速率迅速下降，虽然时间很短，但是如果应用在一些对实时性要求很高的音视频场景下，就会出现卡顿现象。<br>解决方案有多种，根据实际业务需要可以减少ProbeRTT时间甚至直接拿掉ProbeRTT阶段。</p>
<p>3.抗RTT抖动能力差<br>一个典型的场景便是BBR在WIFI弱网下表现不佳，这里的弱网不是指的是网络质量差，速度慢。<br>而是指的是WIFI场景下的稳定性相比于有线网络而言，逊色太多。由于无线网络是共享介质的，几乎无法在信号不冲突的前提下同时发送和接收。<br>所以在WIFI场景下，接入的终端设备一多，RTT抖动会越明显，这种情况下BBR测算出的BDP很可能就不准确了，可能会低于实际带宽数据。</p>
<p>综合来看：<br>个人理解目前为止并没有一种拥塞算法能够适应各种网络环境，是否选择BBR需要根据自己的业务场景需要。BBR存在不少优势的同时，也存在不少劣势。<br>应用BBR之后如存在问题，只要不是先天不足，都可以根据业务需要对BBR进行修改。<br>比如对于下载业务应用BBR的话是否可以将平稳期移除，这样虽然带来了网络颠簸，但是对于用户而言带来的变化时下载更快了。<br>再比如对于稳定性要求高的音视频业务，是否可以缩短ProbeRTT时间甚至直接拿掉ProbeRTT阶段，这样的话就不会存在ProbeRTT阶段发包速率掉下来导致的卡顿。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>至此，对于BBR的一个小结到此结束，由于理解水平有限，可能有不足或理解错误的地方，希望以后回顾时能够再完善下。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ol>
<li>BBR论文 <a href="https://www.cis.upenn.edu/~cis553/files/BBR.pdf" target="_blank" rel="noopener">https://www.cis.upenn.edu/~cis553/files/BBR.pdf</a></li>
<li>[引用1] Startup阶段拥塞窗口计算的滞后性</li>
<li>[引用2] 从TCP拥塞本质看BBR算法及其收敛性</li>
</ol>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://lihaizhou.top">Steven Li</a>
            <p>原文链接：<a href="http://lihaizhou.top/2022/03/01/网络-拥塞控制算法之BBR/">http://lihaizhou.top/2022/03/01/网络-拥塞控制算法之BBR/</a>
            <p>发表日期：<a href="http://lihaizhou.top/2022/03/01/网络-拥塞控制算法之BBR/">March 1st 2022, 10:50:11 pm</a>
            <p>更新日期：<a href="http://lihaizhou.top/2022/03/01/网络-拥塞控制算法之BBR/">April 14th 2022, 4:39:07 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2022/03/20/ART-虚拟机｜Dex2oat-调优实践之路/" title="ART 虚拟机｜Dex2oat 调优实践之路">
                    <div class="nextTitle">ART 虚拟机｜Dex2oat 调优实践之路</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2022/02/10/ANR原理分析及常见案例/" title="ANR原理分析及常见案例">
                    <div class="prevTitle">ANR原理分析及常见案例</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:hellolihaizhou@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/assets/wechat.jpg" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bufferbloat"><span class="toc-number">2.</span> <span class="toc-text">Bufferbloat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BBR-原理"><span class="toc-number">3.</span> <span class="toc-text">BBR 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Startup"><span class="toc-number">3.1.</span> <span class="toc-text">Startup</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ProbeRTT"><span class="toc-number">3.2.</span> <span class="toc-text">ProbeRTT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ProbeBW"><span class="toc-number">3.3.</span> <span class="toc-text">ProbeBW</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BBR-优缺点"><span class="toc-number">4.</span> <span class="toc-text">BBR 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BBR-优势"><span class="toc-number">4.1.</span> <span class="toc-text">BBR 优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BBR-不足之处"><span class="toc-number">4.2.</span> <span class="toc-text">BBR 不足之处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考文章"><span class="toc-number">6.</span> <span class="toc-text">参考文章</span></a></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 25
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/19</span>
            <a class="archive-post-title" href="/2022/04/19/Android-S-Doze模式/">Android S Doze模式</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/20</span>
            <a class="archive-post-title" href="/2022/03/20/ART-虚拟机｜Dex2oat-调优实践之路/">ART 虚拟机｜Dex2oat 调优实践之路</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span>
            <a class="archive-post-title" href="/2022/03/01/网络-拥塞控制算法之BBR/">网络 | 拥塞控制算法之BBR</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/10</span>
            <a class="archive-post-title" href="/2022/02/10/ANR原理分析及常见案例/">ANR原理分析及常见案例</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/27</span>
            <a class="archive-post-title" href="/2021/11/27/优化实践-高刷下列表滑动出现卡顿掉帧/">优化实践: 高刷下列表滑动出现卡顿掉帧</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span>
            <a class="archive-post-title" href="/2021/11/19/优化实践-从系统层面优化应用启动速度/">优化实践:从系统层面优化应用启动速度</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span>
            <a class="archive-post-title" href="/2021/11/11/Systrace角度-拆解分析应用的启动流程/">Systrace角度: 拆解分析应用的启动流程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/08</span>
            <a class="archive-post-title" href="/2021/11/08/案例分析-切换应用后高概率操作无响应-Systrace/">案例分析:打开应用后操作界面无响应(Systrace)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/01</span>
            <a class="archive-post-title" href="/2021/11/01/第三视角-一个ART-GC的优化故事/">第三视角: 一个ART GC的优化故事</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/27</span>
            <a class="archive-post-title" href="/2021/10/27/对Android-S-ART-GC的源码梳理/">对Android S ART GC的源码梳理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/16</span>
            <a class="archive-post-title" href="/2021/10/16/对进程压缩消费Zram速度的优化/">对进程压缩消费Zram速度的优化</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span>
            <a class="archive-post-title" href="/2021/09/18/AMS锁严重竞争导致的整机卡顿/">AMS锁严重竞争导致的整机卡顿</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span>
            <a class="archive-post-title" href="/2021/09/08/GC超时导致的后台应用崩溃问题分析/">GC超时导致的后台应用崩溃问题分析</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2020 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/30</span>
            <a class="archive-post-title" href="/2020/11/30/从tcpdump看miracast的play流程/">从tcpdump看miracast的play流程(工具篇)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/25</span>
            <a class="archive-post-title" href="/2020/11/25/一次SystemServer-OOM导致的系统重启分析之路/">一次SystemServer OOM导致的系统重启分析之路</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span>
            <a class="archive-post-title" href="/2020/06/20/Memory-Barrier读书笔记/">内存屏障</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span>
            <a class="archive-post-title" href="/2020/03/04/谁拖慢了列表的滑动速度/">谁拖慢了列表的滑动速度</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2019 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span>
            <a class="archive-post-title" href="/2019/06/23/一个SharedPreferences写操作导致的ANR问题分析/">一个SharedPreferences写操作导致的ANR问题分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span>
            <a class="archive-post-title" href="/2019/04/12/Launcher应用的重构之路/">Launcher应用的重构之路</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/11</span>
            <a class="archive-post-title" href="/2019/03/11/Android-系统层捕捉所有应用崩溃情况推送到钉钉实践之路/">Android 系统层捕捉所有应用崩溃情况推送到钉钉实践之路</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2018 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span>
            <a class="archive-post-title" href="/2018/06/06/一个滑动冲突问题的分析流程/">一个滑动冲突问题的分析流程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span>
            <a class="archive-post-title" href="/2018/05/31/一个底层内存分配异常导致无法进入launcher问题分析/">一个底层内存分配异常导致无法进入launcher问题分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/29</span>
            <a class="archive-post-title" href="/2018/05/29/一个屏幕滑动无响应问题的分析流程/">一个屏幕滑动无响应问题的分析流程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/17</span>
            <a class="archive-post-title" href="/2018/05/17/一个无法开机问题的分析流程/">一个无法开机问题的分析流程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span>
            <a class="archive-post-title" href="/2018/05/14/基于开源框架SlidingUpPanel二次开发/">基于开源框架SlidingUpPanel二次开发</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="性能">
            <span class="iconfont-archer">&#xe60a;</span>
            性能
        </span>
    
        <span class="sidebar-category-name" data-categories="ANR">
            <span class="iconfont-archer">&#xe60a;</span>
            ANR
        </span>
    
        <span class="sidebar-category-name" data-categories="ART">
            <span class="iconfont-archer">&#xe60a;</span>
            ART
        </span>
    
        <span class="sidebar-category-name" data-categories="Android">
            <span class="iconfont-archer">&#xe60a;</span>
            Android
        </span>
    
        <span class="sidebar-category-name" data-categories="稳定性">
            <span class="iconfont-archer">&#xe60a;</span>
            稳定性
        </span>
    
        <span class="sidebar-category-name" data-categories="Linux">
            <span class="iconfont-archer">&#xe60a;</span>
            Linux
        </span>
    
        <span class="sidebar-category-name" data-categories="网络">
            <span class="iconfont-archer">&#xe60a;</span>
            网络
        </span>
    
        <span class="sidebar-category-name" data-categories="内存">
            <span class="iconfont-archer">&#xe60a;</span>
            内存
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMeta = {
        url: "http://lihaizhou.top",
        root: "/",
        author: "Steven Li"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20210823"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20210823"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20210823" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
